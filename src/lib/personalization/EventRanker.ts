import { Event } from '@/types'\nimport {\n  RecommendationRequest,\n  RecommendationResult,\n  UserPreferences,\n  UserBehavior,\n  ComputedInterest,\n  EventFeatures,\n  MLModelConfig,\n  FeatureImportance\n} from './types'\n\n/**\n * Machine learning-based event scoring and ranking system\n */\nexport class EventRanker {\n  private models: Map<string, MLModelConfig> = new Map()\n  private featureWeights: Map<string, number> = new Map()\n  private rankingFactors: Map<string, (event: Event, context: any) => number> = new Map()\n\n  constructor() {\n    this.initializeRankingFactors()\n    this.initializeFeatureWeights()\n    this.loadModels()\n  }\n\n  /**\n   * Rank events using machine learning models and multiple algorithms\n   */\n  async rankEvents(\n    events: Event[],\n    request: RecommendationRequest,\n    userPreferences: UserPreferences,\n    userBehavior: UserBehavior,\n    computedInterests: ComputedInterest[]\n  ): Promise<RecommendationResult[]> {\n    try {\n      const rankedEvents = []\n\n      for (const event of events) {\n        const score = await this.calculateEventScore(\n          event,\n          request,\n          userPreferences,\n          userBehavior,\n          computedInterests\n        )\n\n        if (score.final_score > 0.1) { // Filter out very low scores\n          rankedEvents.push({\n            event_id: event.id,\n            score: score.final_score,\n            confidence: score.confidence,\n            explanation: {\n              primary_reason: score.primary_reason,\n              contributing_factors: Object.keys(score.factor_scores),\n              algorithm_weights: score.factor_scores\n            },\n            metadata: {\n              algorithm_version: '2.0.0',\n              computation_time_ms: score.computation_time,\n              cache_hit: false\n            }\n          })\n        }\n      }\n\n      // Apply diversity and freshness\n      const diverseEvents = await this.applyDiversityRanking(rankedEvents, events)\n      const finalRanked = await this.applyFreshnessBoost(diverseEvents, events)\n\n      return finalRanked\n        .sort((a, b) => b.score - a.score)\n        .slice(0, request.limit)\n\n    } catch (error) {\n      console.error('Error ranking events:', error)\n      return this.getFallbackRanking(events, request.limit)\n    }\n  }\n\n  /**\n   * Calculate comprehensive event score using multiple factors\n   */\n  private async calculateEventScore(\n    event: Event,\n    request: RecommendationRequest,\n    userPreferences: UserPreferences,\n    userBehavior: UserBehavior,\n    computedInterests: ComputedInterest[]\n  ): Promise<{\n    final_score: number\n    confidence: number\n    primary_reason: string\n    factor_scores: Record<string, number>\n    computation_time: number\n  }> {\n    const startTime = Date.now()\n    const factorScores: Record<string, number> = {}\n\n    // 1. Interest Alignment Score\n    factorScores.interest_alignment = await this.calculateInterestAlignment(\n      event,\n      computedInterests\n    )\n\n    // 2. Preference Matching Score\n    factorScores.preference_matching = await this.calculatePreferenceMatching(\n      event,\n      userPreferences\n    )\n\n    // 3. Behavioral Prediction Score\n    factorScores.behavioral_prediction = await this.calculateBehavioralPrediction(\n      event,\n      userBehavior\n    )\n\n    // 4. Popularity and Trending Score\n    factorScores.popularity_trending = await this.calculatePopularityScore(event)\n\n    // 5. Temporal Relevance Score\n    factorScores.temporal_relevance = await this.calculateTemporalRelevance(\n      event,\n      request\n    )\n\n    // 6. Location Relevance Score (if location provided)\n    if (request.context.location) {\n      factorScores.location_relevance = await this.calculateLocationRelevance(\n        event,\n        request.context.location\n      )\n    }\n\n    // 7. Social Proof Score\n    factorScores.social_proof = await this.calculateSocialProofScore(event, userBehavior)\n\n    // 8. Quality and Trust Score\n    factorScores.quality_trust = await this.calculateQualityScore(event)\n\n    // 9. Novelty and Serendipity Score\n    factorScores.novelty_serendipity = await this.calculateNoveltyScore(\n      event,\n      userBehavior,\n      request.algorithm_config?.novelty_factor || 0.3\n    )\n\n    // Calculate weighted final score\n    const finalScore = this.calculateWeightedScore(factorScores)\n    const confidence = this.calculateScoreConfidence(factorScores, userBehavior)\n    const primaryReason = this.determinePrimaryReason(factorScores)\n\n    return {\n      final_score: Math.min(finalScore, 1.0),\n      confidence,\n      primary_reason: primaryReason,\n      factor_scores: factorScores,\n      computation_time: Date.now() - startTime\n    }\n  }\n\n  /**\n   * Apply Learning-to-Rank (LTR) algorithm\n   */\n  async applyLearningToRank(\n    events: Event[],\n    userContext: any\n  ): Promise<RecommendationResult[]> {\n    try {\n      // Extract features for each event\n      const featureVectors = await Promise.all(\n        events.map(event => this.extractRankingFeatures(event, userContext))\n      )\n\n      // Apply trained ranking model\n      const scores = await this.applyRankingModel(featureVectors)\n\n      // Combine with event IDs and sort\n      const rankedResults = events.map((event, index) => ({\n        event_id: event.id,\n        score: scores[index],\n        confidence: 0.8, // Model confidence\n        explanation: {\n          primary_reason: 'ml_ranking',\n          contributing_factors: ['learning_to_rank'],\n          algorithm_weights: { ml_model: scores[index] }\n        },\n        metadata: {\n          algorithm_version: '2.0.0',\n          computation_time_ms: 0,\n          cache_hit: false\n        }\n      }))\n\n      return rankedResults.sort((a, b) => b.score - a.score)\n\n    } catch (error) {\n      console.error('Learning-to-rank error:', error)\n      return []\n    }\n  }\n\n  /**\n   * Apply collaborative filtering ranking\n   */\n  async applyCollaborativeFiltering(\n    events: Event[],\n    userId: string,\n    similarUsers: string[]\n  ): Promise<Map<string, number>> {\n    const scores = new Map<string, number>()\n\n    try {\n      // Get interaction patterns from similar users\n      for (const event of events) {\n        let totalScore = 0\n        let userCount = 0\n\n        for (const similarUserId of similarUsers) {\n          const userScore = await this.getUserEventScore(similarUserId, event.id)\n          if (userScore > 0) {\n            totalScore += userScore\n            userCount++\n          }\n        }\n\n        if (userCount > 0) {\n          scores.set(event.id, totalScore / userCount)\n        }\n      }\n\n    } catch (error) {\n      console.error('Collaborative filtering error:', error)\n    }\n\n    return scores\n  }\n\n  /**\n   * Apply matrix factorization for implicit feedback\n   */\n  async applyMatrixFactorization(\n    userId: string,\n    eventIds: string[]\n  ): Promise<Map<string, number>> {\n    const scores = new Map<string, number>()\n\n    try {\n      // Simplified matrix factorization simulation\n      // In production, this would use actual trained embeddings\n      const userVector = await this.getUserEmbedding(userId)\n      \n      for (const eventId of eventIds) {\n        const eventVector = await this.getEventEmbedding(eventId)\n        const score = this.dotProduct(userVector, eventVector)\n        scores.set(eventId, Math.max(0, Math.min(1, score)))\n      }\n\n    } catch (error) {\n      console.error('Matrix factorization error:', error)\n    }\n\n    return scores\n  }\n\n  /**\n   * Apply gradient boosting for ranking\n   */\n  async applyGradientBoosting(\n    events: Event[],\n    userContext: any\n  ): Promise<Map<string, number>> {\n    const scores = new Map<string, number>()\n\n    try {\n      // Simulate gradient boosting ensemble\n      for (const event of events) {\n        const features = await this.extractRankingFeatures(event, userContext)\n        \n        // Apply multiple weak learners (simplified)\n        let ensembleScore = 0\n        const numTrees = 10\n        \n        for (let i = 0; i < numTrees; i++) {\n          const treeScore = this.applyDecisionTree(features, i)\n          ensembleScore += treeScore * 0.1 // Learning rate\n        }\n        \n        scores.set(event.id, Math.max(0, Math.min(1, ensembleScore)))\n      }\n\n    } catch (error) {\n      console.error('Gradient boosting error:', error)\n    }\n\n    return scores\n  }\n\n  /**\n   * Calculate feature importance for interpretability\n   */\n  async calculateFeatureImportance(\n    events: Event[],\n    userContext: any\n  ): Promise<FeatureImportance[]> {\n    const importance: FeatureImportance[] = []\n\n    try {\n      // Calculate importance for each feature\n      const features = [\n        'category_match', 'price_preference', 'time_preference',\n        'location_distance', 'popularity_score', 'user_history_match',\n        'social_proof', 'temporal_relevance', 'novelty_score'\n      ]\n\n      for (const feature of features) {\n        const score = await this.calculateFeatureImpact(feature, events, userContext)\n        importance.push({\n          feature_name: feature,\n          importance_score: score,\n          feature_type: this.getFeatureType(feature),\n          explanation: this.getFeatureExplanation(feature)\n        })\n      }\n\n      return importance.sort((a, b) => b.importance_score - a.importance_score)\n\n    } catch (error) {\n      console.error('Feature importance calculation error:', error)\n      return []\n    }\n  }\n\n  /**\n   * Apply diversity ranking to avoid filter bubbles\n   */\n  private async applyDiversityRanking(\n    rankedEvents: RecommendationResult[],\n    events: Event[]\n  ): Promise<RecommendationResult[]> {\n    const diverseResults = []\n    const categoryCount = new Map<string, number>()\n    const venueCount = new Map<string, number>()\n    const maxCategoryRepeat = 3\n    const maxVenueRepeat = 2\n\n    for (const result of rankedEvents) {\n      const event = events.find(e => e.id === result.event_id)\n      if (!event) continue\n\n      const catCount = categoryCount.get(event.category) || 0\n      const venCount = event.venue_id ? (venueCount.get(event.venue_id) || 0) : 0\n\n      // Apply diversity penalty\n      let diversityPenalty = 0\n      if (catCount >= maxCategoryRepeat) diversityPenalty += 0.3\n      if (venCount >= maxVenueRepeat) diversityPenalty += 0.2\n\n      const adjustedScore = Math.max(0, result.score - diversityPenalty)\n\n      if (adjustedScore > 0.1) {\n        diverseResults.push({\n          ...result,\n          score: adjustedScore\n        })\n\n        // Update counts\n        categoryCount.set(event.category, catCount + 1)\n        if (event.venue_id) {\n          venueCount.set(event.venue_id, venCount + 1)\n        }\n      }\n    }\n\n    return diverseResults\n  }\n\n  /**\n   * Apply freshness boost to newer events\n   */\n  private async applyFreshnessBoost(\n    rankedEvents: RecommendationResult[],\n    events: Event[]\n  ): Promise<RecommendationResult[]> {\n    const now = new Date()\n    const oneDayMs = 24 * 60 * 60 * 1000\n    const oneWeekMs = 7 * oneDayMs\n\n    return rankedEvents.map(result => {\n      const event = events.find(e => e.id === result.event_id)\n      if (!event || !event.created_at) return result\n\n      const eventAge = now.getTime() - new Date(event.created_at).getTime()\n      let freshnessBoost = 0\n\n      if (eventAge < oneDayMs) {\n        freshnessBoost = 0.2 // 20% boost for events created today\n      } else if (eventAge < oneWeekMs) {\n        freshnessBoost = 0.1 // 10% boost for events created this week\n      }\n\n      return {\n        ...result,\n        score: Math.min(1.0, result.score + freshnessBoost)\n      }\n    })\n  }\n\n  // Private calculation methods\n\n  private async calculateInterestAlignment(\n    event: Event,\n    computedInterests: ComputedInterest[]\n  ): Promise<number> {\n    const relevantInterest = computedInterests.find(i => i.category === event.category)\n    if (relevantInterest) {\n      return relevantInterest.score * relevantInterest.confidence\n    }\n\n    // Check for related interests\n    const relatedInterests = computedInterests.filter(i => \n      this.getCategoryRelations(event.category).includes(i.category)\n    )\n\n    if (relatedInterests.length > 0) {\n      const avgScore = relatedInterests.reduce((sum, i) => sum + i.score, 0) / relatedInterests.length\n      return avgScore * 0.7 // Discount for indirect match\n    }\n\n    return 0.3 // Neutral score for unknown categories\n  }\n\n  private async calculatePreferenceMatching(\n    event: Event,\n    preferences: UserPreferences\n  ): Promise<number> {\n    let score = 0\n\n    // Category preference\n    if (preferences.categories.includes(event.category)) {\n      score += 0.4\n    }\n\n    // Price preference\n    const eventPrice = event.price || event.price_min || 0\n    const { min, max } = preferences.event_preferences.price_range\n    if (eventPrice >= min && eventPrice <= max) {\n      score += 0.3\n    }\n\n    // Time preference\n    if (event.start_time) {\n      const eventHour = new Date(`2000-01-01T${event.start_time}`).getHours()\n      const timeSlot = this.getTimeSlot(eventHour)\n      if (preferences.event_preferences.preferred_times.includes(timeSlot)) {\n        score += 0.2\n      }\n    }\n\n    // Free event preference\n    if (event.is_free && preferences.event_preferences.price_range.min === 0) {\n      score += 0.1\n    }\n\n    return Math.min(score, 1.0)\n  }\n\n  private async calculateBehavioralPrediction(\n    event: Event,\n    userBehavior: UserBehavior\n  ): Promise<number> {\n    let score = 0\n\n    // Check for similar past interactions\n    const similarInteractions = userBehavior.event_interactions.filter(interaction => {\n      // Look for events in same category, venue, or time period\n      return (\n        interaction.metadata?.category === event.category ||\n        interaction.metadata?.venue_id === event.venue_id ||\n        this.isSimilarTimeSlot(interaction.timestamp, event.start_time)\n      )\n    })\n\n    if (similarInteractions.length > 0) {\n      const positiveInteractions = similarInteractions.filter(i => \n        ['save', 'attend', 'rate'].includes(i.interaction_type)\n      )\n      score = positiveInteractions.length / similarInteractions.length\n    }\n\n    // Check search history alignment\n    const relatedSearches = userBehavior.search_history.filter(search => \n      search.query.toLowerCase().includes(event.category.toLowerCase()) ||\n      search.query.toLowerCase().includes(event.title.toLowerCase())\n    )\n\n    if (relatedSearches.length > 0) {\n      score += 0.2\n    }\n\n    return Math.min(score, 1.0)\n  }\n\n  private async calculatePopularityScore(event: Event): Promise<number> {\n    // Normalize hotness score\n    const hotnessScore = (event.hotness_score || 0) / 100\n    \n    // Factor in view count\n    const viewScore = Math.min((event.view_count || 0) / 1000, 1)\n    \n    // Featured events get boost\n    const featuredBoost = event.is_featured ? 0.3 : 0\n    \n    return Math.min(hotnessScore * 0.5 + viewScore * 0.3 + featuredBoost, 1.0)\n  }\n\n  private async calculateTemporalRelevance(\n    event: Event,\n    request: RecommendationRequest\n  ): Promise<number> {\n    const now = new Date()\n    const eventDate = new Date(event.event_date || event.date || now)\n    \n    const timeDiff = eventDate.getTime() - now.getTime()\n    const daysDiff = timeDiff / (1000 * 60 * 60 * 24)\n    \n    // Optimal range is 1-14 days in the future\n    if (daysDiff < 0) return 0 // Past events\n    if (daysDiff <= 1) return 0.8 // Tomorrow\n    if (daysDiff <= 7) return 1.0 // This week\n    if (daysDiff <= 14) return 0.9 // Next week\n    if (daysDiff <= 30) return 0.7 // This month\n    \n    return 0.3 // Far future\n  }\n\n  private async calculateLocationRelevance(\n    event: Event,\n    userLocation: { lat: number; lng: number; radius_km?: number }\n  ): Promise<number> {\n    if (!event.venue?.latitude || !event.venue?.longitude) {\n      return 0.5 // Neutral for events without location\n    }\n\n    const distance = this.calculateDistance(\n      userLocation.lat,\n      userLocation.lng,\n      event.venue.latitude,\n      event.venue.longitude\n    )\n\n    const maxDistance = userLocation.radius_km || 50\n    \n    if (distance > maxDistance) return 0\n    \n    // Exponential decay based on distance\n    return Math.exp(-distance / (maxDistance / 3))\n  }\n\n  private async calculateSocialProofScore(\n    event: Event,\n    userBehavior: UserBehavior\n  ): Promise<number> {\n    let score = 0\n    \n    // Check if friends/similar users are interested\n    // This would require social connections data\n    \n    // For now, use view count and featured status as proxies\n    const viewScore = Math.min((event.view_count || 0) / 500, 1)\n    const featuredScore = event.is_featured ? 0.5 : 0\n    \n    score = viewScore * 0.6 + featuredScore * 0.4\n    \n    return Math.min(score, 1.0)\n  }\n\n  private async calculateQualityScore(event: Event): Promise<number> {\n    let score = 0.5 // Start with neutral\n    \n    // Check for complete information\n    if (event.description && event.description.length > 50) score += 0.2\n    if (event.image_url) score += 0.1\n    if (event.venue_name) score += 0.1\n    if (event.ticket_url || event.website_url) score += 0.1\n    \n    return Math.min(score, 1.0)\n  }\n\n  private async calculateNoveltyScore(\n    event: Event,\n    userBehavior: UserBehavior,\n    noveltyFactor: number\n  ): Promise<number> {\n    // Check if user has interacted with this category/venue before\n    const categoryInteractions = userBehavior.event_interactions.filter(i => \n      i.metadata?.category === event.category\n    )\n    \n    const venueInteractions = userBehavior.event_interactions.filter(i => \n      i.metadata?.venue_id === event.venue_id\n    )\n    \n    let noveltyScore = 1.0\n    \n    // Reduce novelty based on familiarity\n    if (categoryInteractions.length > 0) {\n      noveltyScore -= Math.min(categoryInteractions.length * 0.1, 0.5)\n    }\n    \n    if (venueInteractions.length > 0) {\n      noveltyScore -= Math.min(venueInteractions.length * 0.15, 0.3)\n    }\n    \n    return Math.max(0, noveltyScore) * noveltyFactor\n  }\n\n  private calculateWeightedScore(factorScores: Record<string, number>): number {\n    const weights = {\n      interest_alignment: 0.25,\n      preference_matching: 0.20,\n      behavioral_prediction: 0.15,\n      popularity_trending: 0.10,\n      temporal_relevance: 0.10,\n      location_relevance: 0.10,\n      social_proof: 0.05,\n      quality_trust: 0.03,\n      novelty_serendipity: 0.02\n    }\n\n    let weightedSum = 0\n    let totalWeight = 0\n\n    for (const [factor, score] of Object.entries(factorScores)) {\n      const weight = weights[factor as keyof typeof weights] || 0\n      weightedSum += score * weight\n      totalWeight += weight\n    }\n\n    return totalWeight > 0 ? weightedSum / totalWeight : 0\n  }\n\n  private calculateScoreConfidence(\n    factorScores: Record<string, number>,\n    userBehavior: UserBehavior\n  ): number {\n    const nonZeroFactors = Object.values(factorScores).filter(score => score > 0).length\n    const totalFactors = Object.keys(factorScores).length\n    \n    const factorCoverage = nonZeroFactors / totalFactors\n    const dataCoverage = Math.min(userBehavior.event_interactions.length / 20, 1)\n    \n    return (factorCoverage * 0.6 + dataCoverage * 0.4)\n  }\n\n  private determinePrimaryReason(factorScores: Record<string, number>): string {\n    let maxScore = 0\n    let primaryFactor = 'interest_alignment'\n    \n    for (const [factor, score] of Object.entries(factorScores)) {\n      if (score > maxScore) {\n        maxScore = score\n        primaryFactor = factor\n      }\n    }\n    \n    return primaryFactor\n  }\n\n  // Helper methods\n\n  private initializeRankingFactors(): void {\n    // Initialize various ranking factor calculators\n    this.rankingFactors.set('recency', (event) => {\n      const daysSinceCreated = (Date.now() - new Date(event.created_at || 0).getTime()) / (1000 * 60 * 60 * 24)\n      return Math.max(0, 1 - daysSinceCreated / 30) // Decay over 30 days\n    })\n\n    this.rankingFactors.set('popularity', (event) => {\n      return (event.hotness_score || 0) / 100\n    })\n\n    this.rankingFactors.set('completeness', (event) => {\n      let score = 0\n      if (event.description) score += 0.25\n      if (event.image_url) score += 0.25\n      if (event.venue_name) score += 0.25\n      if (event.ticket_url) score += 0.25\n      return score\n    })\n  }\n\n  private initializeFeatureWeights(): void {\n    this.featureWeights.set('category_match', 0.3)\n    this.featureWeights.set('price_preference', 0.2)\n    this.featureWeights.set('location_distance', 0.2)\n    this.featureWeights.set('time_preference', 0.1)\n    this.featureWeights.set('popularity', 0.1)\n    this.featureWeights.set('novelty', 0.05)\n    this.featureWeights.set('social_proof', 0.05)\n  }\n\n  private loadModels(): void {\n    // Load pre-trained ML models\n    // In production, these would be loaded from storage\n    this.models.set('collaborative_filtering', {\n      model_type: 'collaborative_filtering',\n      version: '1.0',\n      hyperparameters: { factors: 50, learning_rate: 0.01 },\n      training_data_version: '2024-01',\n      performance_metrics: {\n        precision_at_k: { 5: 0.8, 10: 0.75 },\n        recall_at_k: { 5: 0.6, 10: 0.7 },\n        ndcg_at_k: { 5: 0.85, 10: 0.8 },\n        auc: 0.82,\n        loss: 0.15\n      },\n      created_at: new Date().toISOString(),\n      is_active: true\n    })\n  }\n\n  private async extractRankingFeatures(event: Event, userContext: any): Promise<number[]> {\n    const features = []\n    \n    // Category features (one-hot encoded)\n    const categories = ['music', 'sports', 'arts', 'food', 'tech', 'social', 'business']\n    categories.forEach(cat => {\n      features.push(event.category === cat ? 1 : 0)\n    })\n    \n    // Numerical features\n    features.push(event.price || event.price_min || 0)\n    features.push(event.hotness_score || 0)\n    features.push(event.view_count || 0)\n    features.push(event.is_featured ? 1 : 0)\n    features.push(event.is_free ? 1 : 0)\n    \n    // Temporal features\n    const eventDate = new Date(event.event_date || Date.now())\n    features.push(eventDate.getDay()) // Day of week\n    features.push(eventDate.getHours()) // Hour of day\n    \n    // Location features (if available)\n    if (event.venue?.latitude && userContext.location) {\n      const distance = this.calculateDistance(\n        userContext.location.lat,\n        userContext.location.lng,\n        event.venue.latitude,\n        event.venue.longitude\n      )\n      features.push(distance)\n    } else {\n      features.push(-1) // Missing location indicator\n    }\n    \n    return features\n  }\n\n  private async applyRankingModel(featureVectors: number[][]): Promise<number[]> {\n    // Simplified linear model for demonstration\n    const weights = [\n      0.1, 0.1, 0.2, 0.15, 0.1, 0.05, 0.05, // Category weights\n      -0.001, 0.01, 0.001, 0.3, 0.2, // Numerical feature weights\n      0.05, 0.05, // Temporal weights\n      -0.01 // Distance weight (negative = closer is better)\n    ]\n    \n    return featureVectors.map(features => {\n      let score = 0\n      for (let i = 0; i < Math.min(features.length, weights.length); i++) {\n        score += features[i] * weights[i]\n      }\n      return Math.max(0, Math.min(1, score)) // Normalize to 0-1\n    })\n  }\n\n  private async getUserEventScore(userId: string, eventId: string): Promise<number> {\n    // This would query the database for user-event interaction scores\n    // For now, return a random score for demonstration\n    return Math.random() * 0.8 + 0.1\n  }\n\n  private async getUserEmbedding(userId: string): Promise<number[]> {\n    // Return user embedding vector from trained model\n    // For now, return random vector\n    return Array.from({ length: 50 }, () => Math.random() - 0.5)\n  }\n\n  private async getEventEmbedding(eventId: string): Promise<number[]> {\n    // Return event embedding vector from trained model\n    // For now, return random vector\n    return Array.from({ length: 50 }, () => Math.random() - 0.5)\n  }\n\n  private dotProduct(vectorA: number[], vectorB: number[]): number {\n    return vectorA.reduce((sum, val, i) => sum + val * (vectorB[i] || 0), 0)\n  }\n\n  private applyDecisionTree(features: number[], treeIndex: number): number {\n    // Simplified decision tree for demonstration\n    // In production, this would use actual trained trees\n    \n    if (features[0] > 0.5) { // Category check\n      return features[1] > 100 ? 0.8 : 0.6 // Price check\n    } else {\n      return features[2] > 50 ? 0.7 : 0.4 // Popularity check\n    }\n  }\n\n  private async calculateFeatureImpact(\n    featureName: string,\n    events: Event[],\n    userContext: any\n  ): Promise<number> {\n    // Calculate how much this feature impacts ranking\n    // This would involve permutation importance or SHAP values\n    \n    const importanceMap = {\n      category_match: 0.3,\n      price_preference: 0.25,\n      location_distance: 0.2,\n      popularity_score: 0.15,\n      temporal_relevance: 0.1,\n      user_history_match: 0.08,\n      social_proof: 0.05,\n      novelty_score: 0.02\n    }\n    \n    return importanceMap[featureName as keyof typeof importanceMap] || 0.01\n  }\n\n  private getFeatureType(featureName: string): 'categorical' | 'numerical' | 'embedding' | 'temporal' {\n    if (featureName.includes('category')) return 'categorical'\n    if (featureName.includes('time') || featureName.includes('temporal')) return 'temporal'\n    if (featureName.includes('embedding') || featureName.includes('vector')) return 'embedding'\n    return 'numerical'\n  }\n\n  private getFeatureExplanation(featureName: string): string {\n    const explanations = {\n      category_match: 'How well the event category matches user interests',\n      price_preference: 'How well the event price fits user budget preferences',\n      location_distance: 'Distance from user location to event venue',\n      popularity_score: 'Overall popularity and trending status of the event',\n      temporal_relevance: 'How relevant the event timing is to user preferences',\n      user_history_match: 'Similarity to events the user has engaged with before',\n      social_proof: 'Social signals like views, saves, and attendance',\n      novelty_score: 'How novel or different this event is for the user'\n    }\n    \n    return explanations[featureName as keyof typeof explanations] || 'Feature impact on recommendation score'\n  }\n\n  private getCategoryRelations(category: string): string[] {\n    const relations = {\n      music: ['arts', 'social'],\n      sports: ['social', 'health'],\n      arts: ['music', 'education'],\n      food: ['social', 'health'],\n      tech: ['business', 'education'],\n      social: ['music', 'food', 'arts'],\n      business: ['tech', 'education']\n    }\n    \n    return relations[category as keyof typeof relations] || []\n  }\n\n  private getTimeSlot(hour: number): string {\n    if (hour < 6) return 'late_night'\n    if (hour < 12) return 'morning'\n    if (hour < 17) return 'afternoon'\n    if (hour < 22) return 'evening'\n    return 'late_night'\n  }\n\n  private isSimilarTimeSlot(timestamp: string, eventTime?: string): boolean {\n    if (!eventTime) return false\n    \n    const interactionTime = new Date(timestamp)\n    const eventHour = new Date(`2000-01-01T${eventTime}`).getHours()\n    const interactionHour = interactionTime.getHours()\n    \n    return Math.abs(eventHour - interactionHour) <= 2 // Within 2 hours\n  }\n\n  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371 // Earth's radius in kilometers\n    const dLat = (lat2 - lat1) * Math.PI / 180\n    const dLng = (lng2 - lng1) * Math.PI / 180\n    \n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2)\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    return R * c\n  }\n\n  private getFallbackRanking(events: Event[], limit: number): RecommendationResult[] {\n    return events\n      .sort((a, b) => (b.hotness_score || 0) - (a.hotness_score || 0))\n      .slice(0, limit)\n      .map((event, index) => ({\n        event_id: event.id,\n        score: 0.7 - (index * 0.05),\n        confidence: 0.3,\n        explanation: {\n          primary_reason: 'fallback_popularity',\n          contributing_factors: ['popularity'],\n          algorithm_weights: { popularity: 0.7 }\n        },\n        metadata: {\n          algorithm_version: '2.0.0',\n          computation_time_ms: 0,\n          cache_hit: false\n        }\n      }))\n  }\n}