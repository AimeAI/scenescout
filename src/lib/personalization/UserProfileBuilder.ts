import { SupabaseClient } from '@supabase/supabase-js'\nimport {\n  UserPreferences,\n  UserBehavior,\n  ComputedInterest,\n  EventInteraction,\n  SearchQuery,\n  LocationHistory,\n  PreferenceChange,\n  ConversionEvent,\n  SessionData,\n  UserSimilarity\n} from './types'\nimport { Event, UserProfile } from '@/types'\n\n/**\n * Dynamic user profile construction from behavior and interactions\n */\nexport class UserProfileBuilder {\n  private supabase: SupabaseClient\n  private learningRate: number\n  private decayFactor: number\n  private minInteractionsForProfile: number\n\n  constructor(\n    supabase: SupabaseClient,\n    options: {\n      learningRate?: number\n      decayFactor?: number\n      minInteractionsForProfile?: number\n    } = {}\n  ) {\n    this.supabase = supabase\n    this.learningRate = options.learningRate || 0.1\n    this.decayFactor = options.decayFactor || 0.95 // Weekly decay\n    this.minInteractionsForProfile = options.minInteractionsForProfile || 5\n  }\n\n  /**\n   * Build comprehensive user profile from all available data\n   */\n  async buildUserProfile(userId: string): Promise<{\n    preferences: UserPreferences\n    behavior: UserBehavior\n    computedInterests: ComputedInterest[]\n    profileCompleteness: number\n    lastUpdated: string\n  }> {\n    try {\n      console.log(`Building user profile for ${userId}`)\n\n      // Get existing data\n      const [preferences, behavior, interactions, searches, locations] = await Promise.all([\n        this.getUserPreferences(userId),\n        this.getUserBehavior(userId),\n        this.getUserInteractions(userId),\n        this.getUserSearches(userId),\n        this.getUserLocations(userId)\n      ])\n\n      // Update behavior with latest data\n      const updatedBehavior = await this.updateBehaviorData(\n        behavior,\n        interactions,\n        searches,\n        locations\n      )\n\n      // Compute interests from behavior\n      const computedInterests = await this.computeInterestsFromBehavior(updatedBehavior)\n\n      // Update preferences based on computed interests\n      const updatedPreferences = await this.updatePreferencesFromInterests(\n        preferences,\n        computedInterests,\n        updatedBehavior\n      )\n\n      // Calculate profile completeness\n      const profileCompleteness = this.calculateProfileCompleteness(\n        updatedPreferences,\n        updatedBehavior,\n        computedInterests\n      )\n\n      // Save updated profile\n      await this.saveUserProfile(userId, updatedPreferences, updatedBehavior)\n\n      return {\n        preferences: updatedPreferences,\n        behavior: updatedBehavior,\n        computedInterests,\n        profileCompleteness,\n        lastUpdated: new Date().toISOString()\n      }\n\n    } catch (error) {\n      console.error('Error building user profile:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Update user profile from a new interaction\n   */\n  async updateFromInteraction(\n    userId: string,\n    interaction: {\n      event_id: string\n      interaction_type: string\n      duration_seconds?: number\n      metadata?: Record<string, any>\n    }\n  ): Promise<void> {\n    try {\n      // Get event details\n      const event = await this.getEventDetails(interaction.event_id)\n      if (!event) return\n\n      // Create interaction record\n      const eventInteraction: EventInteraction = {\n        event_id: interaction.event_id,\n        interaction_type: interaction.interaction_type as any,\n        duration_seconds: interaction.duration_seconds,\n        context: {\n          source: 'app',\n          algorithm_version: '1.0'\n        },\n        metadata: {\n          category: event.category,\n          venue_id: event.venue_id,\n          price: event.price || event.price_min,\n          ...interaction.metadata\n        },\n        timestamp: new Date().toISOString()\n      }\n\n      // Store interaction\n      await this.storeInteraction(userId, eventInteraction)\n\n      // Update computed interests incrementally\n      await this.updateInterestsIncremental(userId, eventInteraction, event)\n\n      // Update preferences if significant interaction\n      if (['save', 'attend', 'rate'].includes(interaction.interaction_type)) {\n        await this.updatePreferencesIncremental(userId, event, interaction.interaction_type)\n      }\n\n    } catch (error) {\n      console.error('Error updating from interaction:', error)\n    }\n  }\n\n  /**\n   * Update user profile from search behavior\n   */\n  async updateFromSearch(\n    userId: string,\n    searchData: {\n      query: string\n      filters: Record<string, any>\n      results_count: number\n      clicked_results: string[]\n      location?: { lat: number; lng: number }\n    }\n  ): Promise<void> {\n    try {\n      const searchQuery: SearchQuery = {\n        query: searchData.query,\n        filters: searchData.filters,\n        results_count: searchData.results_count,\n        clicked_results: searchData.clicked_results,\n        location: searchData.location,\n        timestamp: new Date().toISOString()\n      }\n\n      // Store search\n      await this.storeSearch(userId, searchQuery)\n\n      // Extract interests from search query\n      const extractedInterests = this.extractInterestsFromSearch(searchQuery)\n      \n      // Update interests with search signals\n      for (const interest of extractedInterests) {\n        await this.updateInterestFromSearch(userId, interest, searchQuery)\n      }\n\n    } catch (error) {\n      console.error('Error updating from search:', error)\n    }\n  }\n\n  /**\n   * Update location preferences from user movement\n   */\n  async updateFromLocation(\n    userId: string,\n    locationData: {\n      latitude: number\n      longitude: number\n      accuracy: number\n      source: 'gps' | 'ip' | 'manual'\n    }\n  ): Promise<void> {\n    try {\n      const locationHistory: LocationHistory = {\n        latitude: locationData.latitude,\n        longitude: locationData.longitude,\n        accuracy: locationData.accuracy,\n        timestamp: new Date().toISOString(),\n        source: locationData.source\n      }\n\n      // Store location\n      await this.storeLocation(userId, locationHistory)\n\n      // Update location preferences\n      await this.updateLocationPreferences(userId, locationHistory)\n\n    } catch (error) {\n      console.error('Error updating from location:', error)\n    }\n  }\n\n  /**\n   * Find and update similar users based on behavior patterns\n   */\n  async updateUserSimilarities(userId: string): Promise<UserSimilarity[]> {\n    try {\n      const userBehavior = await this.getUserBehavior(userId)\n      const userInterests = await this.getUserComputedInterests(userId)\n      \n      // Find users with similar interests and behaviors\n      const similarUsers = await this.findSimilarUsers(userId, userInterests, userBehavior)\n      \n      // Store similarity scores\n      await this.storeSimilarityScores(userId, similarUsers)\n      \n      return similarUsers\n\n    } catch (error) {\n      console.error('Error updating user similarities:', error)\n      return []\n    }\n  }\n\n  /**\n   * Detect and handle preference changes over time\n   */\n  async detectPreferenceChanges(userId: string): Promise<PreferenceChange[]> {\n    try {\n      const recentBehavior = await this.getRecentBehavior(userId, 30) // Last 30 days\n      const oldBehavior = await this.getOldBehavior(userId, 90, 30) // 30-90 days ago\n      \n      const changes: PreferenceChange[] = []\n      \n      // Compare category preferences\n      const recentCategories = this.extractCategoryPreferences(recentBehavior)\n      const oldCategories = this.extractCategoryPreferences(oldBehavior)\n      \n      for (const category of [...new Set([...recentCategories.keys(), ...oldCategories.keys()])]) {\n        const recentScore = recentCategories.get(category) || 0\n        const oldScore = oldCategories.get(category) || 0\n        const change = Math.abs(recentScore - oldScore)\n        \n        if (change > 0.2) { // Significant change threshold\n          changes.push({\n            field: `category:${category}`,\n            old_value: oldScore,\n            new_value: recentScore,\n            change_reason: 'inferred',\n            timestamp: new Date().toISOString()\n          })\n        }\n      }\n      \n      // Store detected changes\n      await this.storePreferenceChanges(userId, changes)\n      \n      return changes\n\n    } catch (error) {\n      console.error('Error detecting preference changes:', error)\n      return []\n    }\n  }\n\n  /**\n   * Apply temporal decay to user interests and behaviors\n   */\n  async applyTemporalDecay(userId: string): Promise<void> {\n    try {\n      const computedInterests = await this.getUserComputedInterests(userId)\n      const updatedInterests: ComputedInterest[] = []\n      \n      for (const interest of computedInterests) {\n        const daysSinceUpdate = (Date.now() - new Date(interest.last_updated).getTime()) / (1000 * 60 * 60 * 24)\n        const decayFactor = Math.pow(this.decayFactor, daysSinceUpdate / 7) // Weekly decay\n        \n        const updatedInterest: ComputedInterest = {\n          ...interest,\n          score: interest.score * decayFactor,\n          last_updated: new Date().toISOString()\n        }\n        \n        // Only keep interests with meaningful scores\n        if (updatedInterest.score > 0.05) {\n          updatedInterests.push(updatedInterest)\n        }\n      }\n      \n      // Update stored interests\n      await this.storeComputedInterests(userId, updatedInterests)\n\n    } catch (error) {\n      console.error('Error applying temporal decay:', error)\n    }\n  }\n\n  // Private helper methods\n\n  private async getUserPreferences(userId: string): Promise<UserPreferences> {\n    const { data } = await this.supabase\n      .from('user_preferences')\n      .select('*')\n      .eq('user_id', userId)\n      .single()\n\n    return data || this.createDefaultPreferences(userId)\n  }\n\n  private async getUserBehavior(userId: string): Promise<UserBehavior> {\n    const { data } = await this.supabase\n      .from('user_behavior')\n      .select('*')\n      .eq('user_id', userId)\n      .single()\n\n    return data || this.createDefaultBehavior(userId)\n  }\n\n  private async getUserInteractions(userId: string, limit: number = 1000): Promise<EventInteraction[]> {\n    const { data } = await this.supabase\n      .from('user_interactions')\n      .select('*')\n      .eq('user_id', userId)\n      .order('timestamp', { ascending: false })\n      .limit(limit)\n\n    return data || []\n  }\n\n  private async getUserSearches(userId: string, limit: number = 500): Promise<SearchQuery[]> {\n    const { data } = await this.supabase\n      .from('user_searches')\n      .select('*')\n      .eq('user_id', userId)\n      .order('timestamp', { ascending: false })\n      .limit(limit)\n\n    return data || []\n  }\n\n  private async getUserLocations(userId: string, limit: number = 100): Promise<LocationHistory[]> {\n    const { data } = await this.supabase\n      .from('user_location_history')\n      .select('*')\n      .eq('user_id', userId)\n      .order('timestamp', { ascending: false })\n      .limit(limit)\n\n    return data || []\n  }\n\n  private async getUserComputedInterests(userId: string): Promise<ComputedInterest[]> {\n    const { data } = await this.supabase\n      .from('user_computed_interests')\n      .select('*')\n      .eq('user_id', userId)\n      .order('score', { ascending: false })\n\n    return data || []\n  }\n\n  private async updateBehaviorData(\n    behavior: UserBehavior,\n    interactions: EventInteraction[],\n    searches: SearchQuery[],\n    locations: LocationHistory[]\n  ): Promise<UserBehavior> {\n    return {\n      ...behavior,\n      event_interactions: interactions,\n      search_history: searches,\n      location_history: locations,\n      updated_at: new Date().toISOString()\n    }\n  }\n\n  private async computeInterestsFromBehavior(behavior: UserBehavior): Promise<ComputedInterest[]> {\n    const interestMap = new Map<string, {\n      score: number\n      evidence: {\n        interaction_count: number\n        time_spent: number\n        positive_signals: number\n        negative_signals: number\n      }\n    }>()\n\n    // Process event interactions\n    for (const interaction of behavior.event_interactions) {\n      const categories = this.extractCategoriesFromInteraction(interaction)\n      const weight = this.getInteractionWeight(interaction.interaction_type)\n      \n      for (const category of categories) {\n        const existing = interestMap.get(category) || {\n          score: 0,\n          evidence: { interaction_count: 0, time_spent: 0, positive_signals: 0, negative_signals: 0 }\n        }\n        \n        existing.score += weight\n        existing.evidence.interaction_count += 1\n        existing.evidence.time_spent += interaction.duration_seconds || 0\n        \n        if (weight > 0) {\n          existing.evidence.positive_signals += 1\n        } else {\n          existing.evidence.negative_signals += 1\n        }\n        \n        interestMap.set(category, existing)\n      }\n    }\n\n    // Process search history\n    for (const search of behavior.search_history) {\n      const categories = this.extractCategoriesFromSearchQuery(search.query)\n      \n      for (const category of categories) {\n        const existing = interestMap.get(category) || {\n          score: 0,\n          evidence: { interaction_count: 0, time_spent: 0, positive_signals: 0, negative_signals: 0 }\n        }\n        \n        existing.score += 0.2 // Search weight\n        existing.evidence.interaction_count += 1\n        existing.evidence.positive_signals += 1\n        \n        interestMap.set(category, existing)\n      }\n    }\n\n    // Convert to ComputedInterest array\n    const interests: ComputedInterest[] = []\n    const maxScore = Math.max(...Array.from(interestMap.values()).map(v => v.score))\n    \n    for (const [category, data] of interestMap.entries()) {\n      const normalizedScore = maxScore > 0 ? data.score / maxScore : 0\n      const confidence = this.calculateInterestConfidence(data.evidence)\n      \n      if (normalizedScore > 0.05) {\n        interests.push({\n          category,\n          score: normalizedScore,\n          confidence,\n          evidence: data.evidence,\n          last_updated: new Date().toISOString()\n        })\n      }\n    }\n\n    return interests.sort((a, b) => b.score - a.score)\n  }\n\n  private async updatePreferencesFromInterests(\n    preferences: UserPreferences,\n    interests: ComputedInterest[],\n    behavior: UserBehavior\n  ): Promise<UserPreferences> {\n    const updatedPreferences = { ...preferences }\n    \n    // Update category preferences\n    updatedPreferences.categories = interests\n      .filter(i => i.score > 0.3 && i.confidence > 0.5)\n      .map(i => i.category)\n      .slice(0, 10) // Top 10 categories\n\n    // Update location preferences from behavior\n    const locationData = this.analyzeLocationPreferences(behavior.location_history)\n    updatedPreferences.location_preferences = {\n      ...updatedPreferences.location_preferences,\n      ...locationData\n    }\n\n    // Update event preferences from interactions\n    const eventData = this.analyzeEventPreferences(behavior.event_interactions)\n    updatedPreferences.event_preferences = {\n      ...updatedPreferences.event_preferences,\n      ...eventData\n    }\n\n    updatedPreferences.updated_at = new Date().toISOString()\n    \n    return updatedPreferences\n  }\n\n  private calculateProfileCompleteness(\n    preferences: UserPreferences,\n    behavior: UserBehavior,\n    interests: ComputedInterest[]\n  ): number {\n    let score = 0\n    let maxScore = 0\n\n    // Preferences completeness (40%)\n    maxScore += 40\n    if (preferences.categories.length > 0) score += 15\n    if (preferences.location_preferences.preferred_cities.length > 0) score += 10\n    if (preferences.event_preferences.preferred_times.length > 0) score += 8\n    if (preferences.event_preferences.preferred_days.length > 0) score += 7\n\n    // Behavior data completeness (30%)\n    maxScore += 30\n    if (behavior.event_interactions.length >= this.minInteractionsForProfile) score += 15\n    if (behavior.search_history.length > 0) score += 8\n    if (behavior.location_history.length > 0) score += 7\n\n    // Computed interests completeness (30%)\n    maxScore += 30\n    if (interests.length > 0) score += 10\n    if (interests.filter(i => i.confidence > 0.7).length > 0) score += 10\n    if (interests.length >= 5) score += 10\n\n    return maxScore > 0 ? score / maxScore : 0\n  }\n\n  private async saveUserProfile(\n    userId: string,\n    preferences: UserPreferences,\n    behavior: UserBehavior\n  ): Promise<void> {\n    await Promise.all([\n      this.supabase\n        .from('user_preferences')\n        .upsert({ ...preferences, user_id: userId }),\n      \n      this.supabase\n        .from('user_behavior')\n        .upsert({ ...behavior, user_id: userId })\n    ])\n  }\n\n  private createDefaultPreferences(userId: string): UserPreferences {\n    return {\n      id: `pref_${userId}`,\n      user_id: userId,\n      categories: [],\n      location_preferences: {\n        preferred_cities: [],\n        max_distance_km: 50,\n        include_virtual: true\n      },\n      event_preferences: {\n        price_range: { min: 0, max: 1000 },\n        preferred_times: [],\n        preferred_days: [],\n        group_size_preference: 'any',\n        accessibility_needs: []\n      },\n      content_preferences: {\n        preferred_languages: ['en'],\n        content_types: [],\n        duration_preference: 'any'\n      },\n      personalization_settings: {\n        enable_ai_recommendations: true,\n        enable_collaborative_filtering: true,\n        enable_location_based: true,\n        privacy_level: 'private'\n      },\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    }\n  }\n\n  private createDefaultBehavior(userId: string): UserBehavior {\n    return {\n      id: `behavior_${userId}`,\n      user_id: userId,\n      event_interactions: [],\n      search_history: [],\n      location_history: [],\n      preference_changes: [],\n      conversion_events: [],\n      session_data: [],\n      computed_interests: [],\n      similarity_scores: [],\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    }\n  }\n\n  private getInteractionWeight(interactionType: string): number {\n    const weights = {\n      view: 0.1,\n      click: 0.3,\n      save: 0.8,\n      share: 0.6,\n      attend: 1.0,\n      rate: 0.9,\n      review: 0.7\n    }\n    return weights[interactionType as keyof typeof weights] || 0.1\n  }\n\n  private extractCategoriesFromInteraction(interaction: EventInteraction): string[] {\n    const categories = []\n    if (interaction.metadata?.category) {\n      categories.push(interaction.metadata.category)\n    }\n    return categories\n  }\n\n  private extractCategoriesFromSearchQuery(query: string): string[] {\n    const categories = []\n    const lowercaseQuery = query.toLowerCase()\n    \n    const categoryKeywords = {\n      music: ['music', 'concert', 'band', 'singer', 'dj', 'festival'],\n      sports: ['sports', 'game', 'football', 'basketball', 'soccer', 'tennis'],\n      arts: ['art', 'gallery', 'museum', 'theater', 'dance', 'culture'],\n      food: ['food', 'restaurant', 'cooking', 'wine', 'beer', 'dining'],\n      tech: ['tech', 'technology', 'startup', 'coding', 'ai', 'software'],\n      social: ['social', 'networking', 'meetup', 'party', 'community']\n    }\n    \n    for (const [category, keywords] of Object.entries(categoryKeywords)) {\n      if (keywords.some(keyword => lowercaseQuery.includes(keyword))) {\n        categories.push(category)\n      }\n    }\n    \n    return categories\n  }\n\n  private calculateInterestConfidence(evidence: any): number {\n    const { interaction_count, positive_signals, negative_signals, time_spent } = evidence\n    \n    const countConfidence = Math.min(interaction_count / 10, 1)\n    const ratioConfidence = positive_signals / (positive_signals + negative_signals + 1)\n    const timeConfidence = Math.min(time_spent / 3600, 1)\n    \n    return (countConfidence * 0.5 + ratioConfidence * 0.3 + timeConfidence * 0.2)\n  }\n\n  private analyzeLocationPreferences(locationHistory: LocationHistory[]): Partial<UserPreferences['location_preferences']> {\n    if (locationHistory.length === 0) return {}\n\n    // Analyze frequent locations\n    const cityFrequency = new Map<string, number>()\n    let totalDistance = 0\n    let distanceCount = 0\n\n    for (let i = 0; i < locationHistory.length; i++) {\n      const loc = locationHistory[i]\n      \n      // Update city frequency (would need reverse geocoding)\n      if (loc.city_id) {\n        cityFrequency.set(loc.city_id, (cityFrequency.get(loc.city_id) || 0) + 1)\n      }\n      \n      // Calculate travel distances\n      if (i > 0) {\n        const prevLoc = locationHistory[i - 1]\n        const distance = this.calculateDistance(\n          loc.latitude, loc.longitude,\n          prevLoc.latitude, prevLoc.longitude\n        )\n        totalDistance += distance\n        distanceCount++\n      }\n    }\n\n    const avgTravelDistance = distanceCount > 0 ? totalDistance / distanceCount : 25\n    const preferredCities = Array.from(cityFrequency.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([cityId]) => cityId)\n\n    return {\n      preferred_cities: preferredCities,\n      max_distance_km: Math.min(Math.max(avgTravelDistance * 2, 10), 100)\n    }\n  }\n\n  private analyzeEventPreferences(interactions: EventInteraction[]): Partial<UserPreferences['event_preferences']> {\n    if (interactions.length === 0) return {}\n\n    const timeSlots = new Map<string, number>()\n    const dayTypes = new Map<string, number>()\n    const prices: number[] = []\n\n    for (const interaction of interactions) {\n      if (['save', 'attend', 'rate'].includes(interaction.interaction_type)) {\n        // Analyze time preferences\n        const timestamp = new Date(interaction.timestamp)\n        const timeSlot = this.getTimeSlot(timestamp.getHours())\n        timeSlots.set(timeSlot, (timeSlots.get(timeSlot) || 0) + 1)\n\n        // Analyze day preferences\n        const dayType = timestamp.getDay() === 0 || timestamp.getDay() === 6 ? 'weekends' : 'weekdays'\n        dayTypes.set(dayType, (dayTypes.get(dayType) || 0) + 1)\n\n        // Analyze price preferences\n        if (interaction.metadata?.price && typeof interaction.metadata.price === 'number') {\n          prices.push(interaction.metadata.price)\n        }\n      }\n    }\n\n    const preferredTimes = Array.from(timeSlots.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 2)\n      .map(([time]) => time)\n\n    const preferredDays = Array.from(dayTypes.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 1)\n      .map(([day]) => day)\n\n    let priceRange = { min: 0, max: 1000 }\n    if (prices.length > 0) {\n      prices.sort((a, b) => a - b)\n      const q1 = prices[Math.floor(prices.length * 0.25)]\n      const q3 = prices[Math.floor(prices.length * 0.75)]\n      priceRange = { min: Math.max(0, q1 - 10), max: q3 + 20 }\n    }\n\n    return {\n      preferred_times: preferredTimes,\n      preferred_days: preferredDays,\n      price_range: priceRange\n    }\n  }\n\n  private getTimeSlot(hour: number): string {\n    if (hour < 6) return 'late_night'\n    if (hour < 12) return 'morning'\n    if (hour < 17) return 'afternoon'\n    if (hour < 22) return 'evening'\n    return 'late_night'\n  }\n\n  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371\n    const dLat = (lat2 - lat1) * Math.PI / 180\n    const dLng = (lng2 - lng1) * Math.PI / 180\n    \n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2)\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    return R * c\n  }\n\n  // Additional methods for specific functionality\n\n  private async getEventDetails(eventId: string): Promise<Event | null> {\n    const { data } = await this.supabase\n      .from('events')\n      .select('*')\n      .eq('id', eventId)\n      .single()\n    \n    return data\n  }\n\n  private async storeInteraction(userId: string, interaction: EventInteraction): Promise<void> {\n    await this.supabase\n      .from('user_interactions')\n      .insert({\n        user_id: userId,\n        ...interaction\n      })\n  }\n\n  private async storeSearch(userId: string, search: SearchQuery): Promise<void> {\n    await this.supabase\n      .from('user_searches')\n      .insert({\n        user_id: userId,\n        ...search\n      })\n  }\n\n  private async storeLocation(userId: string, location: LocationHistory): Promise<void> {\n    await this.supabase\n      .from('user_location_history')\n      .insert({\n        user_id: userId,\n        ...location\n      })\n  }\n\n  private async storeComputedInterests(userId: string, interests: ComputedInterest[]): Promise<void> {\n    // Delete existing interests\n    await this.supabase\n      .from('user_computed_interests')\n      .delete()\n      .eq('user_id', userId)\n    \n    // Insert new interests\n    if (interests.length > 0) {\n      await this.supabase\n        .from('user_computed_interests')\n        .insert(interests.map(interest => ({ user_id: userId, ...interest })))\n    }\n  }\n\n  private async updateInterestsIncremental(\n    userId: string,\n    interaction: EventInteraction,\n    event: Event\n  ): Promise<void> {\n    const weight = this.getInteractionWeight(interaction.interaction_type)\n    const category = event.category\n    \n    // Get existing interest\n    const { data: existingInterest } = await this.supabase\n      .from('user_computed_interests')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('category', category)\n      .single()\n    \n    if (existingInterest) {\n      // Update existing interest\n      const newScore = existingInterest.score + (weight * this.learningRate)\n      const newEvidence = {\n        interaction_count: existingInterest.evidence.interaction_count + 1,\n        time_spent: existingInterest.evidence.time_spent + (interaction.duration_seconds || 0),\n        positive_signals: existingInterest.evidence.positive_signals + (weight > 0 ? 1 : 0),\n        negative_signals: existingInterest.evidence.negative_signals + (weight <= 0 ? 1 : 0)\n      }\n      \n      await this.supabase\n        .from('user_computed_interests')\n        .update({\n          score: Math.min(newScore, 1.0),\n          evidence: newEvidence,\n          confidence: this.calculateInterestConfidence(newEvidence),\n          last_updated: new Date().toISOString()\n        })\n        .eq('user_id', userId)\n        .eq('category', category)\n    } else {\n      // Create new interest\n      const evidence = {\n        interaction_count: 1,\n        time_spent: interaction.duration_seconds || 0,\n        positive_signals: weight > 0 ? 1 : 0,\n        negative_signals: weight <= 0 ? 1 : 0\n      }\n      \n      await this.supabase\n        .from('user_computed_interests')\n        .insert({\n          user_id: userId,\n          category,\n          score: Math.max(0, weight * this.learningRate),\n          confidence: this.calculateInterestConfidence(evidence),\n          evidence,\n          last_updated: new Date().toISOString()\n        })\n    }\n  }\n\n  private async updatePreferencesIncremental(\n    userId: string,\n    event: Event,\n    interactionType: string\n  ): Promise<void> {\n    const preferences = await this.getUserPreferences(userId)\n    \n    // Update category preferences\n    if (!preferences.categories.includes(event.category)) {\n      preferences.categories.push(event.category)\n      preferences.categories = preferences.categories.slice(0, 10) // Keep top 10\n    }\n    \n    // Update price preferences based on event price\n    const eventPrice = event.price || event.price_min || 0\n    if (eventPrice > 0 && ['save', 'attend'].includes(interactionType)) {\n      const currentRange = preferences.event_preferences.price_range\n      preferences.event_preferences.price_range = {\n        min: Math.min(currentRange.min, eventPrice - 10),\n        max: Math.max(currentRange.max, eventPrice + 20)\n      }\n    }\n    \n    preferences.updated_at = new Date().toISOString()\n    \n    await this.supabase\n      .from('user_preferences')\n      .upsert(preferences)\n  }\n\n  private extractInterestsFromSearch(search: SearchQuery): string[] {\n    return this.extractCategoriesFromSearchQuery(search.query)\n  }\n\n  private async updateInterestFromSearch(\n    userId: string,\n    category: string,\n    search: SearchQuery\n  ): Promise<void> {\n    const searchWeight = 0.1 // Lower weight for search signals\n    \n    // Similar to updateInterestsIncremental but with search-specific logic\n    const { data: existingInterest } = await this.supabase\n      .from('user_computed_interests')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('category', category)\n      .single()\n    \n    if (existingInterest) {\n      const newScore = existingInterest.score + searchWeight\n      await this.supabase\n        .from('user_computed_interests')\n        .update({\n          score: Math.min(newScore, 1.0),\n          last_updated: new Date().toISOString()\n        })\n        .eq('user_id', userId)\n        .eq('category', category)\n    } else {\n      await this.supabase\n        .from('user_computed_interests')\n        .insert({\n          user_id: userId,\n          category,\n          score: searchWeight,\n          confidence: 0.3, // Lower confidence for search-only interests\n          evidence: {\n            interaction_count: 1,\n            time_spent: 0,\n            positive_signals: 1,\n            negative_signals: 0\n          },\n          last_updated: new Date().toISOString()\n        })\n    }\n  }\n\n  private async updateLocationPreferences(\n    userId: string,\n    location: LocationHistory\n  ): Promise<void> {\n    // Implementation for updating location preferences\n    // This would involve reverse geocoding and city detection\n  }\n\n  private async findSimilarUsers(\n    userId: string,\n    interests: ComputedInterest[],\n    behavior: UserBehavior\n  ): Promise<UserSimilarity[]> {\n    // Simplified similarity calculation\n    // In production, this would use more sophisticated algorithms\n    \n    const similarities: UserSimilarity[] = []\n    \n    // This would query for users with similar interest patterns\n    // For now, return empty array\n    \n    return similarities\n  }\n\n  private async storeSimilarityScores(userId: string, similarities: UserSimilarity[]): Promise<void> {\n    // Delete existing similarities\n    await this.supabase\n      .from('user_similarities')\n      .delete()\n      .eq('user_id', userId)\n    \n    // Insert new similarities\n    if (similarities.length > 0) {\n      await this.supabase\n        .from('user_similarities')\n        .insert(similarities.map(sim => ({ user_id: userId, ...sim })))\n    }\n  }\n\n  private async getRecentBehavior(userId: string, days: number): Promise<UserBehavior> {\n    const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString()\n    \n    const [interactions, searches] = await Promise.all([\n      this.supabase\n        .from('user_interactions')\n        .select('*')\n        .eq('user_id', userId)\n        .gte('timestamp', cutoff),\n      \n      this.supabase\n        .from('user_searches')\n        .select('*')\n        .eq('user_id', userId)\n        .gte('timestamp', cutoff)\n    ])\n    \n    return {\n      ...this.createDefaultBehavior(userId),\n      event_interactions: interactions.data || [],\n      search_history: searches.data || []\n    }\n  }\n\n  private async getOldBehavior(userId: string, endDays: number, startDays: number): Promise<UserBehavior> {\n    const endCutoff = new Date(Date.now() - endDays * 24 * 60 * 60 * 1000).toISOString()\n    const startCutoff = new Date(Date.now() - startDays * 24 * 60 * 60 * 1000).toISOString()\n    \n    const [interactions, searches] = await Promise.all([\n      this.supabase\n        .from('user_interactions')\n        .select('*')\n        .eq('user_id', userId)\n        .gte('timestamp', endCutoff)\n        .lte('timestamp', startCutoff),\n      \n      this.supabase\n        .from('user_searches')\n        .select('*')\n        .eq('user_id', userId)\n        .gte('timestamp', endCutoff)\n        .lte('timestamp', startCutoff)\n    ])\n    \n    return {\n      ...this.createDefaultBehavior(userId),\n      event_interactions: interactions.data || [],\n      search_history: searches.data || []\n    }\n  }\n\n  private extractCategoryPreferences(behavior: UserBehavior): Map<string, number> {\n    const categoryScores = new Map<string, number>()\n    \n    for (const interaction of behavior.event_interactions) {\n      const category = interaction.metadata?.category\n      if (category) {\n        const weight = this.getInteractionWeight(interaction.interaction_type)\n        categoryScores.set(category, (categoryScores.get(category) || 0) + weight)\n      }\n    }\n    \n    return categoryScores\n  }\n\n  private async storePreferenceChanges(userId: string, changes: PreferenceChange[]): Promise<void> {\n    if (changes.length > 0) {\n      await this.supabase\n        .from('user_preference_changes')\n        .insert(changes.map(change => ({ user_id: userId, ...change })))\n    }\n  }\n}