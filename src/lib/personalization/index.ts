// Main exports for the personalization system\nexport { PersonalizationEngine } from './PersonalizationEngine'\nexport { LocationService } from './LocationService'\nexport { InterestMatcher } from './InterestMatcher'\nexport { EventRanker } from './EventRanker'\nexport { RecommendationCache } from './RecommendationCache'\nexport { UserProfileBuilder } from './UserProfileBuilder'\n\n// Export types\nexport type {\n  UserPreferences,\n  UserBehavior,\n  ComputedInterest,\n  EventInteraction,\n  SearchQuery,\n  LocationHistory,\n  PreferenceChange,\n  ConversionEvent,\n  SessionData,\n  UserSimilarity,\n  RecommendationRequest,\n  RecommendationResponse,\n  RecommendationResult,\n  ABTestVariant,\n  PersonalizationMetrics,\n  LocationContext,\n  EventFeatures,\n  SimilarUser,\n  RecommendationExplanation,\n  CacheEntry,\n  CacheMetrics,\n  MLModelConfig,\n  FeatureImportance,\n  RealTimeUpdate,\n  PersonalizationConfig\n} from './types'\n\n// Utility functions for creating personalization instances\nexport function createPersonalizationEngine(\n  supabaseUrl: string,\n  supabaseKey: string,\n  config?: any\n) {\n  return new PersonalizationEngine(supabaseUrl, supabaseKey, config)\n}\n\n// Default configuration presets\nexport const PersonalizationPresets = {\n  // Conservative preset with emphasis on explicit preferences\n  conservative: {\n    algorithms: {\n      collaborative_filtering: { enabled: true, weight: 0.2 },\n      content_based: { enabled: true, weight: 0.5 },\n      location_based: { enabled: true, weight: 0.2 },\n      trending: { enabled: true, weight: 0.1 }\n    },\n    diversity: {\n      enable_diversity: true,\n      diversity_lambda: 0.3,\n      max_same_category: 2,\n      max_same_venue: 1\n    }\n  },\n  \n  // Aggressive preset with heavy ML emphasis\n  aggressive: {\n    algorithms: {\n      collaborative_filtering: { enabled: true, weight: 0.4 },\n      content_based: { enabled: true, weight: 0.3 },\n      location_based: { enabled: true, weight: 0.2 },\n      trending: { enabled: true, weight: 0.1 }\n    },\n    diversity: {\n      enable_diversity: true,\n      diversity_lambda: 0.7,\n      max_same_category: 4,\n      max_same_venue: 3\n    }\n  },\n  \n  // Discovery preset for new users\n  discovery: {\n    algorithms: {\n      collaborative_filtering: { enabled: false, weight: 0 },\n      content_based: { enabled: true, weight: 0.3 },\n      location_based: { enabled: true, weight: 0.3 },\n      trending: { enabled: true, weight: 0.4 }\n    },\n    diversity: {\n      enable_diversity: true,\n      diversity_lambda: 0.8,\n      max_same_category: 2,\n      max_same_venue: 1\n    }\n  }\n}\n\n// Helper function to get appropriate preset based on user profile\nexport function getRecommendedPreset(\n  userInteractionCount: number,\n  profileCompleteness: number\n): keyof typeof PersonalizationPresets {\n  if (userInteractionCount < 10 || profileCompleteness < 0.3) {\n    return 'discovery'\n  } else if (userInteractionCount < 50 || profileCompleteness < 0.7) {\n    return 'conservative'\n  } else {\n    return 'aggressive'\n  }\n}\n\n// Constants\nexport const PERSONALIZATION_CONSTANTS = {\n  MIN_INTERACTIONS_FOR_COLLABORATIVE: 5,\n  MIN_INTERACTIONS_FOR_PROFILE: 3,\n  DEFAULT_CACHE_TTL: 1800, // 30 minutes\n  MAX_RECOMMENDATIONS: 100,\n  DEFAULT_LOCATION_RADIUS: 50, // km\n  INTEREST_DECAY_RATE: 0.95, // weekly\n  SIMILARITY_THRESHOLD: 0.2,\n  CONFIDENCE_THRESHOLD: 0.5\n} as const\n\n// Validation utilities\nexport const PersonalizationValidators = {\n  validateRecommendationRequest: (request: RecommendationRequest): string[] => {\n    const errors: string[] = []\n    \n    if (!request.user_id) {\n      errors.push('user_id is required')\n    }\n    \n    if (request.limit && (request.limit < 1 || request.limit > PERSONALIZATION_CONSTANTS.MAX_RECOMMENDATIONS)) {\n      errors.push(`limit must be between 1 and ${PERSONALIZATION_CONSTANTS.MAX_RECOMMENDATIONS}`)\n    }\n    \n    if (request.context.location) {\n      const { lat, lng } = request.context.location\n      if (lat < -90 || lat > 90) {\n        errors.push('Invalid latitude')\n      }\n      if (lng < -180 || lng > 180) {\n        errors.push('Invalid longitude')\n      }\n    }\n    \n    return errors\n  },\n  \n  validateUserPreferences: (preferences: Partial<UserPreferences>): string[] => {\n    const errors: string[] = []\n    \n    if (preferences.location_preferences?.max_distance_km) {\n      const distance = preferences.location_preferences.max_distance_km\n      if (distance < 1 || distance > 1000) {\n        errors.push('max_distance_km must be between 1 and 1000')\n      }\n    }\n    \n    if (preferences.event_preferences?.price_range) {\n      const { min, max } = preferences.event_preferences.price_range\n      if (min < 0 || max < min) {\n        errors.push('Invalid price range')\n      }\n    }\n    \n    return errors\n  }\n}\n\n// Performance monitoring utilities\nexport class PersonalizationMonitor {\n  private metrics: Map<string, number[]> = new Map()\n  \n  recordMetric(name: string, value: number): void {\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, [])\n    }\n    \n    const values = this.metrics.get(name)!\n    values.push(value)\n    \n    // Keep only last 1000 values\n    if (values.length > 1000) {\n      values.shift()\n    }\n  }\n  \n  getMetricSummary(name: string): {\n    avg: number\n    min: number\n    max: number\n    p95: number\n    count: number\n  } | null {\n    const values = this.metrics.get(name)\n    if (!values || values.length === 0) return null\n    \n    const sorted = [...values].sort((a, b) => a - b)\n    const p95Index = Math.floor(sorted.length * 0.95)\n    \n    return {\n      avg: values.reduce((sum, v) => sum + v, 0) / values.length,\n      min: sorted[0],\n      max: sorted[sorted.length - 1],\n      p95: sorted[p95Index],\n      count: values.length\n    }\n  }\n  \n  getAllMetrics(): Record<string, ReturnType<PersonalizationMonitor['getMetricSummary']>> {\n    const result: Record<string, any> = {}\n    \n    for (const metricName of this.metrics.keys()) {\n      result[metricName] = this.getMetricSummary(metricName)\n    }\n    \n    return result\n  }\n}\n\n// Create global monitor instance\nexport const personalizationMonitor = new PersonalizationMonitor()\n\n// Error classes\nexport class PersonalizationError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: any\n  ) {\n    super(message)\n    this.name = 'PersonalizationError'\n  }\n}\n\nexport class RecommendationError extends PersonalizationError {\n  constructor(message: string, details?: any) {\n    super(message, 'RECOMMENDATION_ERROR', details)\n    this.name = 'RecommendationError'\n  }\n}\n\nexport class CacheError extends PersonalizationError {\n  constructor(message: string, details?: any) {\n    super(message, 'CACHE_ERROR', details)\n    this.name = 'CacheError'\n  }\n}\n\n// Utility function to handle personalization errors\nexport function handlePersonalizationError(error: unknown): {\n  message: string\n  code: string\n  shouldRetry: boolean\n} {\n  if (error instanceof PersonalizationError) {\n    return {\n      message: error.message,\n      code: error.code,\n      shouldRetry: error.code !== 'VALIDATION_ERROR'\n    }\n  }\n  \n  if (error instanceof Error) {\n    return {\n      message: error.message,\n      code: 'UNKNOWN_ERROR',\n      shouldRetry: true\n    }\n  }\n  \n  return {\n    message: 'An unknown error occurred',\n    code: 'UNKNOWN_ERROR',\n    shouldRetry: true\n  }\n}\n\n// Export version info\nexport const PERSONALIZATION_VERSION = '2.0.0'\nexport const PERSONALIZATION_BUILD_DATE = new Date().toISOString()\n\n// Feature flags\nexport const PERSONALIZATION_FEATURES = {\n  COLLABORATIVE_FILTERING: true,\n  CONTENT_BASED_FILTERING: true,\n  LOCATION_BASED_RECOMMENDATIONS: true,\n  REAL_TIME_UPDATES: true,\n  A_B_TESTING: true,\n  ADVANCED_CACHING: true,\n  ML_RANKING: true,\n  BEHAVIORAL_ANALYSIS: true,\n  SIMILARITY_MATCHING: true,\n  TREND_ANALYSIS: true\n} as const\n\n// Development utilities\nexport const PersonalizationDev = {\n  // Generate mock recommendation request for testing\n  createMockRecommendationRequest: (overrides?: Partial<RecommendationRequest>): RecommendationRequest => ({\n    user_id: 'test-user-123',\n    context: {\n      location: { lat: 37.7749, lng: -122.4194, radius_km: 25 },\n      time_range: {\n        start: new Date().toISOString(),\n        end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\n      }\n    },\n    filters: {\n      categories: ['music', 'arts'],\n      price_range: { min: 0, max: 100 }\n    },\n    algorithm_config: {\n      enable_collaborative: true,\n      enable_content_based: true,\n      enable_location_based: true,\n      enable_trending: true,\n      diversity_factor: 0.5,\n      novelty_factor: 0.3\n    },\n    limit: 20,\n    ...overrides\n  }),\n  \n  // Generate mock user preferences for testing\n  createMockUserPreferences: (userId: string): UserPreferences => ({\n    id: `pref_${userId}`,\n    user_id: userId,\n    categories: ['music', 'arts', 'food'],\n    location_preferences: {\n      preferred_cities: ['san-francisco', 'oakland'],\n      max_distance_km: 50,\n      include_virtual: true\n    },\n    event_preferences: {\n      price_range: { min: 0, max: 150 },\n      preferred_times: ['evening', 'afternoon'],\n      preferred_days: ['weekends', 'weekdays'],\n      group_size_preference: 'small_group',\n      accessibility_needs: []\n    },\n    content_preferences: {\n      preferred_languages: ['en'],\n      content_types: ['music', 'interactive'],\n      duration_preference: 'medium'\n    },\n    personalization_settings: {\n      enable_ai_recommendations: true,\n      enable_collaborative_filtering: true,\n      enable_location_based: true,\n      privacy_level: 'private'\n    },\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString()\n  })\n}\n\n// Type guards\nexport const PersonalizationTypeGuards = {\n  isRecommendationRequest: (obj: any): obj is RecommendationRequest => {\n    return obj && typeof obj.user_id === 'string' && typeof obj.limit === 'number'\n  },\n  \n  isUserPreferences: (obj: any): obj is UserPreferences => {\n    return obj && typeof obj.user_id === 'string' && Array.isArray(obj.categories)\n  },\n  \n  isEventInteraction: (obj: any): obj is EventInteraction => {\n    return obj && typeof obj.event_id === 'string' && typeof obj.interaction_type === 'string'\n  }\n}\n"