import { Event } from '@/types'\nimport { UserBehavior, ComputedInterest, EventFeatures } from './types'\n\n/**\n * AI-powered interest and category matching system\n */\nexport class InterestMatcher {\n  private categoryEmbeddings: Map<string, number[]> = new Map()\n  private userInterestVectors: Map<string, number[]> = new Map()\n  private eventFeatureCache: Map<string, EventFeatures> = new Map()\n\n  constructor() {\n    this.initializeCategoryEmbeddings()\n  }\n\n  /**\n   * Calculate interest match score between user and event\n   */\n  async calculateInterestScore(\n    userId: string,\n    event: Event,\n    userBehavior: UserBehavior,\n    computedInterests: ComputedInterest[]\n  ): Promise<{\n    score: number\n    confidence: number\n    breakdown: {\n      category_match: number\n      content_similarity: number\n      behavioral_signals: number\n      novelty_bonus: number\n    }\n  }> {\n    try {\n      // Get or compute event features\n      const eventFeatures = await this.getEventFeatures(event)\n      \n      // Get user interest vector\n      const userVector = await this.getUserInterestVector(userId, userBehavior, computedInterests)\n      \n      // Calculate different matching scores\n      const categoryMatch = this.calculateCategoryMatch(event.category, computedInterests)\n      const contentSimilarity = this.calculateContentSimilarity(eventFeatures, userVector)\n      const behavioralSignals = this.calculateBehavioralSignals(event, userBehavior)\n      const noveltyBonus = this.calculateNoveltyBonus(event, userBehavior)\n      \n      // Weighted combination\n      const score = (\n        categoryMatch * 0.4 +\n        contentSimilarity * 0.3 +\n        behavioralSignals * 0.2 +\n        noveltyBonus * 0.1\n      )\n      \n      // Calculate confidence based on data availability\n      const confidence = this.calculateConfidence(userBehavior, computedInterests)\n      \n      return {\n        score: Math.min(score, 1.0),\n        confidence,\n        breakdown: {\n          category_match: categoryMatch,\n          content_similarity: contentSimilarity,\n          behavioral_signals: behavioralSignals,\n          novelty_bonus: noveltyBonus\n        }\n      }\n    } catch (error) {\n      console.error('Error calculating interest score:', error)\n      return {\n        score: 0.5, // neutral score on error\n        confidence: 0.1,\n        breakdown: {\n          category_match: 0.5,\n          content_similarity: 0,\n          behavioral_signals: 0,\n          novelty_bonus: 0\n        }\n      }\n    }\n  }\n\n  /**\n   * Find similar events based on content and features\n   */\n  async findSimilarEvents(\n    targetEvent: Event,\n    candidateEvents: Event[],\n    threshold: number = 0.7\n  ): Promise<Array<{\n    event: Event\n    similarity: number\n    reasons: string[]\n  }>> {\n    const targetFeatures = await this.getEventFeatures(targetEvent)\n    const similarities = []\n\n    for (const candidate of candidateEvents) {\n      if (candidate.id === targetEvent.id) continue\n\n      const candidateFeatures = await this.getEventFeatures(candidate)\n      const similarity = this.calculateEventSimilarity(targetFeatures, candidateFeatures)\n      \n      if (similarity >= threshold) {\n        const reasons = this.getSimilarityReasons(targetEvent, candidate, similarity)\n        similarities.push({\n          event: candidate,\n          similarity,\n          reasons\n        })\n      }\n    }\n\n    return similarities.sort((a, b) => b.similarity - a.similarity)\n  }\n\n  /**\n   * Extract and classify user interests from behavior\n   */\n  async extractInterestsFromBehavior(userBehavior: UserBehavior): Promise<ComputedInterest[]> {\n    const interestMap = new Map<string, {\n      score: number\n      evidence: {\n        interaction_count: number\n        time_spent: number\n        positive_signals: number\n        negative_signals: number\n      }\n    }>()\n\n    // Analyze event interactions\n    for (const interaction of userBehavior.event_interactions) {\n      const weight = this.getInteractionWeight(interaction.interaction_type)\n      const categories = await this.extractCategoriesFromInteraction(interaction)\n      \n      for (const category of categories) {\n        const existing = interestMap.get(category) || {\n          score: 0,\n          evidence: { interaction_count: 0, time_spent: 0, positive_signals: 0, negative_signals: 0 }\n        }\n        \n        existing.score += weight\n        existing.evidence.interaction_count += 1\n        existing.evidence.time_spent += interaction.duration_seconds || 0\n        \n        if (weight > 0) {\n          existing.evidence.positive_signals += 1\n        } else {\n          existing.evidence.negative_signals += 1\n        }\n        \n        interestMap.set(category, existing)\n      }\n    }\n\n    // Analyze search history\n    for (const search of userBehavior.search_history) {\n      const categories = this.extractCategoriesFromSearch(search.query)\n      for (const category of categories) {\n        const existing = interestMap.get(category) || {\n          score: 0,\n          evidence: { interaction_count: 0, time_spent: 0, positive_signals: 0, negative_signals: 0 }\n        }\n        existing.score += 0.3 // Search signals are weaker than direct interactions\n        existing.evidence.interaction_count += 1\n        interestMap.set(category, existing)\n      }\n    }\n\n    // Convert to ComputedInterest array\n    const interests: ComputedInterest[] = []\n    const maxScore = Math.max(...Array.from(interestMap.values()).map(v => v.score))\n    \n    for (const [category, data] of interestMap.entries()) {\n      const normalizedScore = maxScore > 0 ? data.score / maxScore : 0\n      const confidence = this.calculateInterestConfidence(data.evidence)\n      \n      if (normalizedScore > 0.1) { // Only include interests with meaningful scores\n        interests.push({\n          category,\n          score: normalizedScore,\n          confidence,\n          evidence: data.evidence,\n          last_updated: new Date().toISOString()\n        })\n      }\n    }\n\n    return interests.sort((a, b) => b.score - a.score)\n  }\n\n  /**\n   * Predict user interest in new categories\n   */\n  async predictCategoryInterest(\n    userId: string,\n    category: string,\n    userBehavior: UserBehavior,\n    computedInterests: ComputedInterest[]\n  ): Promise<{\n    predicted_score: number\n    confidence: number\n    reasoning: string[]\n  }> {\n    try {\n      // Find related categories that user has shown interest in\n      const relatedCategories = this.findRelatedCategories(category)\n      const relatedInterests = computedInterests.filter(interest => \n        relatedCategories.includes(interest.category)\n      )\n\n      if (relatedInterests.length === 0) {\n        return {\n          predicted_score: 0.5, // neutral for unknown categories\n          confidence: 0.1,\n          reasoning: ['No related interest data available']\n        }\n      }\n\n      // Calculate predicted score based on related interests\n      const avgRelatedScore = relatedInterests.reduce((sum, interest) => sum + interest.score, 0) / relatedInterests.length\n      const maxRelatedScore = Math.max(...relatedInterests.map(i => i.score))\n      \n      // Adjust based on category similarity\n      const categoryEmbedding = this.categoryEmbeddings.get(category) || []\n      const userVector = await this.getUserInterestVector(userId, userBehavior, computedInterests)\n      const semanticSimilarity = this.cosineSimilarity(categoryEmbedding, userVector)\n      \n      const predictedScore = (avgRelatedScore * 0.6 + maxRelatedScore * 0.3 + semanticSimilarity * 0.1)\n      const confidence = Math.min(relatedInterests.length / 5, 1) * 0.8 // Higher confidence with more data\n      \n      const reasoning = [\n        `Based on interest in related categories: ${relatedInterests.map(i => i.category).join(', ')}`,\n        `Average related interest score: ${avgRelatedScore.toFixed(2)}`,\n        `Semantic similarity: ${semanticSimilarity.toFixed(2)}`\n      ]\n      \n      return {\n        predicted_score: Math.min(predictedScore, 1.0),\n        confidence,\n        reasoning\n      }\n    } catch (error) {\n      console.error('Error predicting category interest:', error)\n      return {\n        predicted_score: 0.5,\n        confidence: 0.1,\n        reasoning: ['Error in prediction calculation']\n      }\n    }\n  }\n\n  /**\n   * Generate content-based recommendations using TF-IDF and embeddings\n   */\n  async generateContentRecommendations(\n    userInterests: ComputedInterest[],\n    candidateEvents: Event[],\n    limit: number = 20\n  ): Promise<Array<{\n    event: Event\n    score: number\n    matching_interests: string[]\n  }>> {\n    const recommendations = []\n\n    for (const event of candidateEvents) {\n      const eventFeatures = await this.getEventFeatures(event)\n      let totalScore = 0\n      const matchingInterests = []\n\n      for (const interest of userInterests) {\n        const categoryScore = this.calculateCategoryMatchScore(interest.category, event.category)\n        const contentScore = this.calculateContentMatchScore(eventFeatures, interest)\n        \n        const interestScore = (categoryScore * 0.7 + contentScore * 0.3) * interest.score\n        totalScore += interestScore\n        \n        if (interestScore > 0.1) {\n          matchingInterests.push(interest.category)\n        }\n      }\n\n      if (totalScore > 0.1) {\n        recommendations.push({\n          event,\n          score: Math.min(totalScore, 1.0),\n          matching_interests: matchingInterests\n        })\n      }\n    }\n\n    return recommendations\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n  }\n\n  /**\n   * Update user interest vector based on new interaction\n   */\n  async updateUserInterestVector(\n    userId: string,\n    eventId: string,\n    interactionType: string,\n    duration?: number\n  ): Promise<void> {\n    try {\n      // Get current user vector\n      const currentVector = this.userInterestVectors.get(userId) || new Array(100).fill(0)\n      \n      // Get event features\n      const eventData = await this.getEventData(eventId)\n      if (!eventData) return\n      \n      const eventFeatures = await this.getEventFeatures(eventData)\n      const weight = this.getInteractionWeight(interactionType)\n      const timeWeight = duration ? Math.min(duration / 300, 1) : 1 // 5 minutes = full weight\n      \n      // Update vector with weighted event features\n      const finalWeight = weight * timeWeight * 0.1 // Learning rate\n      \n      for (let i = 0; i < currentVector.length && i < eventFeatures.embeddings.content_embedding.length; i++) {\n        currentVector[i] += eventFeatures.embeddings.content_embedding[i] * finalWeight\n      }\n      \n      // Normalize vector to prevent unbounded growth\n      this.normalizeVector(currentVector)\n      \n      // Store updated vector\n      this.userInterestVectors.set(userId, currentVector)\n      \n    } catch (error) {\n      console.error('Error updating user interest vector:', error)\n    }\n  }\n\n  // Private helper methods\n\n  private initializeCategoryEmbeddings(): void {\n    // Initialize embeddings for major categories\n    // In production, these would be learned from data\n    const categories = [\n      'music', 'sports', 'arts', 'food', 'tech', 'social', \n      'business', 'education', 'health', 'family', 'other'\n    ]\n    \n    categories.forEach((category, index) => {\n      // Create simple one-hot-like embeddings with some noise for similarity\n      const embedding = new Array(100).fill(0)\n      embedding[index * 9] = 1.0\n      embedding[index * 9 + 1] = 0.8\n      embedding[index * 9 + 2] = 0.6\n      \n      this.categoryEmbeddings.set(category, embedding)\n    })\n  }\n\n  private async getEventFeatures(event: Event): Promise<EventFeatures> {\n    const cacheKey = event.id\n    if (this.eventFeatureCache.has(cacheKey)) {\n      return this.eventFeatureCache.get(cacheKey)!\n    }\n\n    const features = this.computeEventFeatures(event)\n    this.eventFeatureCache.set(cacheKey, features)\n    \n    // Implement cache eviction\n    if (this.eventFeatureCache.size > 10000) {\n      const firstKey = this.eventFeatureCache.keys().next().value\n      this.eventFeatureCache.delete(firstKey)\n    }\n    \n    return features\n  }\n\n  private computeEventFeatures(event: Event): EventFeatures {\n    // Create category vector\n    const categoryVector = this.categoryEmbeddings.get(event.category) || new Array(100).fill(0)\n    \n    // Compute content embedding from description, title, tags\n    const contentEmbedding = this.computeContentEmbedding(event)\n    \n    // Compute temporal features\n    const temporalFeatures = this.computeTemporalFeatures(event)\n    \n    return {\n      event_id: event.id,\n      features: {\n        category_vector: categoryVector,\n        price_tier: this.normalizePriceTier(event.price || event.price_min || 0),\n        popularity_score: (event.hotness_score || 0) / 100,\n        temporal_features: temporalFeatures,\n        venue_features: {\n          capacity_tier: 0.5, // Default\n          venue_type: event.venue?.name?.toLowerCase().includes('outdoor') ? 'outdoor' : 'indoor',\n          accessibility_score: 0.8 // Default high\n        },\n        content_features: {\n          has_video: !!event.video_url,\n          has_images: !!event.image_url,\n          description_length: (event.description?.length || 0) / 1000,\n          language: 'en' // Default\n        },\n        social_features: {\n          attendee_count: 0, // Would need to compute\n          rating_average: 0,\n          review_count: 0,\n          share_count: event.view_count || 0\n        }\n      },\n      embeddings: {\n        content_embedding: contentEmbedding,\n        categorical_embedding: categoryVector,\n        user_interaction_embedding: new Array(50).fill(0) // Computed separately\n      },\n      computed_at: new Date().toISOString()\n    }\n  }\n\n  private computeContentEmbedding(event: Event): number[] {\n    // Simple TF-IDF-like embedding based on text content\n    const text = [\n      event.title || '',\n      event.description || '',\n      ...(event.tags || [])\n    ].join(' ').toLowerCase()\n    \n    const words = text.split(/\\s+/).filter(word => word.length > 2)\n    const embedding = new Array(100).fill(0)\n    \n    // Simple hash-based embedding\n    words.forEach(word => {\n      const hash = this.simpleHash(word) % 100\n      embedding[hash] += 1 / words.length\n    })\n    \n    return embedding\n  }\n\n  private computeTemporalFeatures(event: Event): any {\n    const eventDate = new Date(event.event_date || event.date || Date.now())\n    const startTime = event.start_time ? new Date(`1970-01-01T${event.start_time}`) : new Date()\n    \n    return {\n      hour_of_day: startTime.getHours() / 24,\n      day_of_week: eventDate.getDay() / 7,\n      season: (eventDate.getMonth() % 12) / 12,\n      is_weekend: eventDate.getDay() === 0 || eventDate.getDay() === 6,\n      is_holiday: false // Would need holiday detection\n    }\n  }\n\n  private normalizePriceTier(price: number): number {\n    // Normalize price to 0-1 scale\n    if (price === 0) return 0\n    if (price <= 20) return 0.2\n    if (price <= 50) return 0.4\n    if (price <= 100) return 0.6\n    if (price <= 200) return 0.8\n    return 1.0\n  }\n\n  private async getUserInterestVector(\n    userId: string,\n    userBehavior: UserBehavior,\n    computedInterests: ComputedInterest[]\n  ): Promise<number[]> {\n    if (this.userInterestVectors.has(userId)) {\n      return this.userInterestVectors.get(userId)!\n    }\n\n    // Build user vector from computed interests\n    const vector = new Array(100).fill(0)\n    \n    for (const interest of computedInterests) {\n      const categoryEmbedding = this.categoryEmbeddings.get(interest.category)\n      if (categoryEmbedding) {\n        for (let i = 0; i < vector.length && i < categoryEmbedding.length; i++) {\n          vector[i] += categoryEmbedding[i] * interest.score\n        }\n      }\n    }\n    \n    this.normalizeVector(vector)\n    this.userInterestVectors.set(userId, vector)\n    \n    return vector\n  }\n\n  private calculateCategoryMatch(eventCategory: string, computedInterests: ComputedInterest[]): number {\n    const directMatch = computedInterests.find(i => i.category === eventCategory)\n    if (directMatch) {\n      return directMatch.score * directMatch.confidence\n    }\n    \n    // Look for related categories\n    const relatedCategories = this.findRelatedCategories(eventCategory)\n    const relatedMatches = computedInterests.filter(i => relatedCategories.includes(i.category))\n    \n    if (relatedMatches.length > 0) {\n      const avgScore = relatedMatches.reduce((sum, match) => sum + match.score, 0) / relatedMatches.length\n      return avgScore * 0.7 // Discount for indirect match\n    }\n    \n    return 0.3 // Neutral score for unknown categories\n  }\n\n  private calculateContentSimilarity(eventFeatures: EventFeatures, userVector: number[]): number {\n    return this.cosineSimilarity(eventFeatures.embeddings.content_embedding, userVector)\n  }\n\n  private calculateBehavioralSignals(event: Event, userBehavior: UserBehavior): number {\n    let score = 0\n    \n    // Check for similar events in user's history\n    const similarEvents = userBehavior.event_interactions.filter(interaction => {\n      // This would need more sophisticated similarity checking\n      return interaction.metadata?.category === event.category\n    })\n    \n    if (similarEvents.length > 0) {\n      const positiveInteractions = similarEvents.filter(i => \n        ['save', 'attend', 'rate'].includes(i.interaction_type)\n      ).length\n      score += positiveInteractions / similarEvents.length\n    }\n    \n    return Math.min(score, 1.0)\n  }\n\n  private calculateNoveltyBonus(event: Event, userBehavior: UserBehavior): number {\n    // Check if this is a new category or venue for the user\n    const hasInteractedWithCategory = userBehavior.event_interactions.some(i => \n      i.metadata?.category === event.category\n    )\n    \n    const hasInteractedWithVenue = userBehavior.event_interactions.some(i => \n      i.metadata?.venue_id === event.venue_id\n    )\n    \n    let noveltyScore = 0\n    if (!hasInteractedWithCategory) noveltyScore += 0.3\n    if (!hasInteractedWithVenue) noveltyScore += 0.2\n    \n    return Math.min(noveltyScore, 0.5) // Cap novelty bonus\n  }\n\n  private calculateConfidence(userBehavior: UserBehavior, computedInterests: ComputedInterest[]): number {\n    const interactionCount = userBehavior.event_interactions.length\n    const interestCount = computedInterests.length\n    const avgInterestConfidence = computedInterests.length > 0 ? \n      computedInterests.reduce((sum, i) => sum + i.confidence, 0) / computedInterests.length : 0\n    \n    // Confidence increases with more data\n    const dataConfidence = Math.min((interactionCount / 20) + (interestCount / 10), 1)\n    \n    return (dataConfidence * 0.7 + avgInterestConfidence * 0.3)\n  }\n\n  private cosineSimilarity(vectorA: number[], vectorB: number[]): number {\n    if (vectorA.length !== vectorB.length) {\n      console.warn('Vector length mismatch in cosine similarity')\n      return 0\n    }\n    \n    let dotProduct = 0\n    let normA = 0\n    let normB = 0\n    \n    for (let i = 0; i < vectorA.length; i++) {\n      dotProduct += vectorA[i] * vectorB[i]\n      normA += vectorA[i] * vectorA[i]\n      normB += vectorB[i] * vectorB[i]\n    }\n    \n    normA = Math.sqrt(normA)\n    normB = Math.sqrt(normB)\n    \n    if (normA === 0 || normB === 0) return 0\n    \n    return dotProduct / (normA * normB)\n  }\n\n  private normalizeVector(vector: number[]): void {\n    const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0))\n    if (norm > 0) {\n      for (let i = 0; i < vector.length; i++) {\n        vector[i] /= norm\n      }\n    }\n  }\n\n  private getInteractionWeight(interactionType: string): number {\n    const weights = {\n      view: 0.1,\n      click: 0.3,\n      save: 0.8,\n      share: 0.6,\n      attend: 1.0,\n      rate: 0.9,\n      review: 0.7\n    }\n    return weights[interactionType as keyof typeof weights] || 0.1\n  }\n\n  private async extractCategoriesFromInteraction(interaction: any): Promise<string[]> {\n    // This would fetch event data and extract categories\n    // For now, return the category from metadata\n    return [interaction.metadata?.category].filter(Boolean)\n  }\n\n  private extractCategoriesFromSearch(query: string): string[] {\n    const categories = []\n    const lowercaseQuery = query.toLowerCase()\n    \n    // Simple keyword matching - in production, use NLP\n    const categoryKeywords = {\n      music: ['music', 'concert', 'band', 'singer', 'dj', 'festival'],\n      sports: ['sports', 'game', 'football', 'basketball', 'soccer', 'tennis'],\n      arts: ['art', 'gallery', 'museum', 'theater', 'dance', 'culture'],\n      food: ['food', 'restaurant', 'cooking', 'wine', 'beer', 'dining'],\n      tech: ['tech', 'technology', 'startup', 'coding', 'ai', 'software'],\n      social: ['social', 'networking', 'meetup', 'party', 'community']\n    }\n    \n    for (const [category, keywords] of Object.entries(categoryKeywords)) {\n      if (keywords.some(keyword => lowercaseQuery.includes(keyword))) {\n        categories.push(category)\n      }\n    }\n    \n    return categories\n  }\n\n  private calculateInterestConfidence(evidence: any): number {\n    const { interaction_count, positive_signals, negative_signals, time_spent } = evidence\n    \n    // Higher confidence with more interactions and time spent\n    const countConfidence = Math.min(interaction_count / 10, 1)\n    const ratioConfidence = positive_signals / (positive_signals + negative_signals + 1)\n    const timeConfidence = Math.min(time_spent / 3600, 1) // 1 hour = full confidence\n    \n    return (countConfidence * 0.5 + ratioConfidence * 0.3 + timeConfidence * 0.2)\n  }\n\n  private findRelatedCategories(category: string): string[] {\n    const relations = {\n      music: ['arts', 'social'],\n      sports: ['social', 'health'],\n      arts: ['music', 'education', 'social'],\n      food: ['social', 'health'],\n      tech: ['business', 'education'],\n      social: ['music', 'food', 'arts'],\n      business: ['tech', 'education'],\n      education: ['tech', 'arts', 'business'],\n      health: ['sports', 'food', 'education'],\n      family: ['social', 'education', 'health']\n    }\n    \n    return relations[category as keyof typeof relations] || []\n  }\n\n  private calculateEventSimilarity(features1: EventFeatures, features2: EventFeatures): number {\n    // Calculate similarity based on multiple features\n    const contentSim = this.cosineSimilarity(\n      features1.embeddings.content_embedding,\n      features2.embeddings.content_embedding\n    )\n    \n    const categorySim = this.cosineSimilarity(\n      features1.features.category_vector,\n      features2.features.category_vector\n    )\n    \n    const priceSim = 1 - Math.abs(features1.features.price_tier - features2.features.price_tier)\n    \n    return (contentSim * 0.5 + categorySim * 0.3 + priceSim * 0.2)\n  }\n\n  private getSimilarityReasons(event1: Event, event2: Event, similarity: number): string[] {\n    const reasons = []\n    \n    if (event1.category === event2.category) {\n      reasons.push(`Same category: ${event1.category}`)\n    }\n    \n    if (event1.venue_id === event2.venue_id) {\n      reasons.push(`Same venue: ${event1.venue_name}`)\n    }\n    \n    const price1 = event1.price || event1.price_min || 0\n    const price2 = event2.price || event2.price_min || 0\n    if (Math.abs(price1 - price2) < 20) {\n      reasons.push('Similar price range')\n    }\n    \n    if (similarity > 0.8) {\n      reasons.push('High content similarity')\n    }\n    \n    return reasons\n  }\n\n  private calculateCategoryMatchScore(userCategory: string, eventCategory: string): number {\n    if (userCategory === eventCategory) return 1.0\n    \n    const relatedCategories = this.findRelatedCategories(eventCategory)\n    if (relatedCategories.includes(userCategory)) return 0.7\n    \n    return 0.1\n  }\n\n  private calculateContentMatchScore(eventFeatures: EventFeatures, interest: ComputedInterest): number {\n    const categoryEmbedding = this.categoryEmbeddings.get(interest.category) || []\n    return this.cosineSimilarity(eventFeatures.embeddings.content_embedding, categoryEmbedding)\n  }\n\n  private async getEventData(eventId: string): Promise<Event | null> {\n    // This would fetch event data from database\n    // For now, return null (would need database connection)\n    return null\n  }\n\n  private simpleHash(str: string): number {\n    let hash = 0\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash // Convert to 32-bit integer\n    }\n    return Math.abs(hash)\n  }\n}