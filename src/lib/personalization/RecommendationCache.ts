import { CacheEntry, CacheMetrics, RealTimeUpdate } from './types'\n\n/**\n * High-performance caching layer for personalized recommendations\n * Supports multiple cache levels, TTL, and real-time invalidation\n */\nexport class RecommendationCache {\n  private memoryCache: Map<string, CacheEntry<any>> = new Map()\n  private lruKeys: string[] = []\n  private maxMemoryEntries: number\n  private defaultTTL: number\n  private metrics: CacheMetrics\n  private redisClient: any // Redis client if available\n  private enableRedis: boolean\n\n  constructor(options: {\n    maxMemoryEntries?: number\n    defaultTTL?: number\n    enableRedis?: boolean\n    redisConfig?: any\n  } = {}) {\n    this.maxMemoryEntries = options.maxMemoryEntries || 10000\n    this.defaultTTL = options.defaultTTL || 1800 // 30 minutes\n    this.enableRedis = options.enableRedis || false\n\n    this.metrics = {\n      hit_rate: 0,\n      miss_rate: 0,\n      eviction_rate: 0,\n      average_ttl: this.defaultTTL,\n      memory_usage: 0,\n      entry_count: 0,\n      popular_keys: []\n    }\n\n    if (this.enableRedis && options.redisConfig) {\n      this.initializeRedis(options.redisConfig)\n    }\n\n    // Start periodic cleanup\n    this.startCleanupTimer()\n  }\n\n  /**\n   * Get cached value with automatic TTL checking\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      // Check memory cache first (L1)\n      const memoryResult = await this.getFromMemory<T>(key)\n      if (memoryResult !== null) {\n        this.updateMetrics('hit', 'memory')\n        return memoryResult\n      }\n\n      // Check Redis cache (L2) if enabled\n      if (this.enableRedis && this.redisClient) {\n        const redisResult = await this.getFromRedis<T>(key)\n        if (redisResult !== null) {\n          // Populate memory cache for faster future access\n          await this.setInMemory(key, redisResult, this.defaultTTL)\n          this.updateMetrics('hit', 'redis')\n          return redisResult\n        }\n      }\n\n      this.updateMetrics('miss')\n      return null\n\n    } catch (error) {\n      console.error('Cache get error:', error)\n      this.updateMetrics('miss')\n      return null\n    }\n  }\n\n  /**\n   * Set value in cache with optional TTL\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttl: number = this.defaultTTL,\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    try {\n      // Set in memory cache (L1)\n      await this.setInMemory(key, value, ttl, metadata)\n\n      // Set in Redis cache (L2) if enabled\n      if (this.enableRedis && this.redisClient) {\n        await this.setInRedis(key, value, ttl, metadata)\n      }\n\n    } catch (error) {\n      console.error('Cache set error:', error)\n    }\n  }\n\n  /**\n   * Delete specific cache entry\n   */\n  async delete(key: string): Promise<void> {\n    try {\n      // Delete from memory\n      if (this.memoryCache.has(key)) {\n        this.memoryCache.delete(key)\n        this.lruKeys = this.lruKeys.filter(k => k !== key)\n        this.updateEntryCount()\n      }\n\n      // Delete from Redis\n      if (this.enableRedis && this.redisClient) {\n        await this.redisClient.del(key)\n      }\n\n    } catch (error) {\n      console.error('Cache delete error:', error)\n    }\n  }\n\n  /**\n   * Invalidate cache entries matching pattern\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    let invalidatedCount = 0\n\n    try {\n      // Invalidate memory cache\n      const memoryKeys = Array.from(this.memoryCache.keys())\n      const regex = this.patternToRegex(pattern)\n      \n      for (const key of memoryKeys) {\n        if (regex.test(key)) {\n          await this.delete(key)\n          invalidatedCount++\n        }\n      }\n\n      // Invalidate Redis cache\n      if (this.enableRedis && this.redisClient) {\n        const redisKeys = await this.redisClient.keys(pattern)\n        if (redisKeys.length > 0) {\n          await this.redisClient.del(...redisKeys)\n          invalidatedCount += redisKeys.length\n        }\n      }\n\n      return invalidatedCount\n\n    } catch (error) {\n      console.error('Cache pattern invalidation error:', error)\n      return 0\n    }\n  }\n\n  /**\n   * Bulk get multiple keys\n   */\n  async mget<T>(keys: string[]): Promise<Map<string, T | null>> {\n    const results = new Map<string, T | null>()\n\n    try {\n      // Try memory cache first\n      const memoryMisses: string[] = []\n      \n      for (const key of keys) {\n        const memoryResult = await this.getFromMemory<T>(key)\n        if (memoryResult !== null) {\n          results.set(key, memoryResult)\n        } else {\n          memoryMisses.push(key)\n        }\n      }\n\n      // Try Redis for memory misses\n      if (memoryMisses.length > 0 && this.enableRedis && this.redisClient) {\n        const redisResults = await this.mgetFromRedis<T>(memoryMisses)\n        \n        for (const [key, value] of redisResults.entries()) {\n          results.set(key, value)\n          \n          // Populate memory cache for hits\n          if (value !== null) {\n            await this.setInMemory(key, value, this.defaultTTL)\n          }\n        }\n      }\n\n      // Set null for complete misses\n      for (const key of keys) {\n        if (!results.has(key)) {\n          results.set(key, null)\n        }\n      }\n\n      return results\n\n    } catch (error) {\n      console.error('Cache mget error:', error)\n      \n      // Return null for all keys on error\n      for (const key of keys) {\n        results.set(key, null)\n      }\n      return results\n    }\n  }\n\n  /**\n   * Bulk set multiple key-value pairs\n   */\n  async mset<T>(entries: Map<string, T>, ttl: number = this.defaultTTL): Promise<void> {\n    try {\n      // Set in memory cache\n      for (const [key, value] of entries.entries()) {\n        await this.setInMemory(key, value, ttl)\n      }\n\n      // Set in Redis cache\n      if (this.enableRedis && this.redisClient) {\n        await this.msetInRedis(entries, ttl)\n      }\n\n    } catch (error) {\n      console.error('Cache mset error:', error)\n    }\n  }\n\n  /**\n   * Get cache statistics and metrics\n   */\n  async getMetrics(): Promise<CacheMetrics> {\n    this.updateMemoryUsage()\n    this.updatePopularKeys()\n    return { ...this.metrics }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  async clear(): Promise<void> {\n    try {\n      // Clear memory cache\n      this.memoryCache.clear()\n      this.lruKeys = []\n      \n      // Clear Redis cache\n      if (this.enableRedis && this.redisClient) {\n        await this.redisClient.flushall()\n      }\n      \n      this.updateEntryCount()\n\n    } catch (error) {\n      console.error('Cache clear error:', error)\n    }\n  }\n\n  /**\n   * Warm up cache with precomputed values\n   */\n  async warmUp(entries: Array<{\n    key: string\n    value: any\n    ttl?: number\n    metadata?: Record<string, any>\n  }>): Promise<void> {\n    try {\n      console.log(`Warming up cache with ${entries.length} entries`)\n      \n      for (const entry of entries) {\n        await this.set(\n          entry.key,\n          entry.value,\n          entry.ttl || this.defaultTTL,\n          entry.metadata\n        )\n      }\n      \n      console.log('Cache warm-up completed')\n\n    } catch (error) {\n      console.error('Cache warm-up error:', error)\n    }\n  }\n\n  /**\n   * Handle real-time cache invalidation\n   */\n  async handleRealTimeUpdate(update: RealTimeUpdate): Promise<void> {\n    try {\n      if (!update.requires_recomputation) {\n        return\n      }\n\n      const invalidationPatterns = this.getInvalidationPatterns(update)\n      \n      for (const pattern of invalidationPatterns) {\n        await this.invalidatePattern(pattern)\n      }\n\n      console.log(`Cache invalidated for update: ${update.type}`)\n\n    } catch (error) {\n      console.error('Real-time cache invalidation error:', error)\n    }\n  }\n\n  /**\n   * Get cache health status\n   */\n  async getHealthStatus(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy'\n    memory_cache: {\n      entries: number\n      hit_rate: number\n      memory_usage_mb: number\n    }\n    redis_cache?: {\n      connected: boolean\n      memory_usage_mb?: number\n    }\n    issues: string[]\n  }> {\n    const issues: string[] = []\n    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy'\n\n    // Check memory cache health\n    if (this.metrics.hit_rate < 0.5) {\n      issues.push('Low cache hit rate')\n      status = 'degraded'\n    }\n\n    if (this.metrics.entry_count > this.maxMemoryEntries * 0.9) {\n      issues.push('Memory cache near capacity')\n      status = 'degraded'\n    }\n\n    // Check Redis health\n    let redisStatus = undefined\n    if (this.enableRedis) {\n      try {\n        redisStatus = {\n          connected: this.redisClient && await this.redisClient.ping() === 'PONG'\n        }\n        \n        if (!redisStatus.connected) {\n          issues.push('Redis connection failed')\n          status = 'unhealthy'\n        }\n      } catch (error) {\n        issues.push('Redis health check failed')\n        status = 'unhealthy'\n      }\n    }\n\n    return {\n      status,\n      memory_cache: {\n        entries: this.metrics.entry_count,\n        hit_rate: this.metrics.hit_rate,\n        memory_usage_mb: this.metrics.memory_usage / (1024 * 1024)\n      },\n      redis_cache: redisStatus,\n      issues\n    }\n  }\n\n  // Private methods\n\n  private async getFromMemory<T>(key: string): Promise<T | null> {\n    const entry = this.memoryCache.get(key)\n    \n    if (!entry) {\n      return null\n    }\n\n    // Check TTL\n    if (this.isExpired(entry)) {\n      await this.delete(key)\n      return null\n    }\n\n    // Update LRU\n    this.updateLRU(key)\n    \n    // Update hit count\n    entry.hit_count++\n    entry.last_accessed = Date.now()\n\n    return entry.value as T\n  }\n\n  private async setInMemory<T>(\n    key: string,\n    value: T,\n    ttl: number,\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    // Check if we need to evict entries\n    if (this.memoryCache.size >= this.maxMemoryEntries) {\n      await this.evictLRU()\n    }\n\n    const entry: CacheEntry<T> = {\n      key,\n      value,\n      ttl,\n      created_at: Date.now(),\n      hit_count: 0,\n      last_accessed: Date.now(),\n      metadata\n    }\n\n    this.memoryCache.set(key, entry)\n    this.updateLRU(key)\n    this.updateEntryCount()\n  }\n\n  private async getFromRedis<T>(key: string): Promise<T | null> {\n    if (!this.redisClient) return null\n\n    try {\n      const result = await this.redisClient.get(key)\n      return result ? JSON.parse(result) : null\n    } catch (error) {\n      console.error('Redis get error:', error)\n      return null\n    }\n  }\n\n  private async setInRedis<T>(\n    key: string,\n    value: T,\n    ttl: number,\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    if (!this.redisClient) return\n\n    try {\n      const serialized = JSON.stringify({ value, metadata })\n      await this.redisClient.setex(key, ttl, serialized)\n    } catch (error) {\n      console.error('Redis set error:', error)\n    }\n  }\n\n  private async mgetFromRedis<T>(keys: string[]): Promise<Map<string, T | null>> {\n    const results = new Map<string, T | null>()\n\n    if (!this.redisClient || keys.length === 0) {\n      for (const key of keys) {\n        results.set(key, null)\n      }\n      return results\n    }\n\n    try {\n      const values = await this.redisClient.mget(...keys)\n      \n      for (let i = 0; i < keys.length; i++) {\n        const value = values[i]\n        results.set(keys[i], value ? JSON.parse(value).value : null)\n      }\n\n    } catch (error) {\n      console.error('Redis mget error:', error)\n      for (const key of keys) {\n        results.set(key, null)\n      }\n    }\n\n    return results\n  }\n\n  private async msetInRedis<T>(entries: Map<string, T>, ttl: number): Promise<void> {\n    if (!this.redisClient || entries.size === 0) return\n\n    try {\n      const pipeline = this.redisClient.pipeline()\n      \n      for (const [key, value] of entries.entries()) {\n        const serialized = JSON.stringify({ value })\n        pipeline.setex(key, ttl, serialized)\n      }\n      \n      await pipeline.exec()\n\n    } catch (error) {\n      console.error('Redis mset error:', error)\n    }\n  }\n\n  private isExpired(entry: CacheEntry<any>): boolean {\n    return Date.now() - entry.created_at > entry.ttl * 1000\n  }\n\n  private updateLRU(key: string): void {\n    // Remove key from current position\n    this.lruKeys = this.lruKeys.filter(k => k !== key)\n    \n    // Add to front (most recently used)\n    this.lruKeys.unshift(key)\n    \n    // Limit LRU list size\n    if (this.lruKeys.length > this.maxMemoryEntries * 1.1) {\n      this.lruKeys = this.lruKeys.slice(0, this.maxMemoryEntries)\n    }\n  }\n\n  private async evictLRU(): Promise<void> {\n    // Remove least recently used entries\n    const evictCount = Math.max(1, Math.floor(this.maxMemoryEntries * 0.1)) // Evict 10%\n    \n    for (let i = 0; i < evictCount && this.lruKeys.length > 0; i++) {\n      const keyToEvict = this.lruKeys.pop()\n      if (keyToEvict) {\n        this.memoryCache.delete(keyToEvict)\n        this.updateMetrics('eviction')\n      }\n    }\n  }\n\n  private updateMetrics(operation: 'hit' | 'miss' | 'eviction', source?: 'memory' | 'redis'): void {\n    const now = Date.now()\n    \n    switch (operation) {\n      case 'hit':\n        this.metrics.hit_rate = this.calculateMovingAverage(this.metrics.hit_rate, 1, 0.9)\n        this.metrics.miss_rate = this.calculateMovingAverage(this.metrics.miss_rate, 0, 0.9)\n        break\n        \n      case 'miss':\n        this.metrics.hit_rate = this.calculateMovingAverage(this.metrics.hit_rate, 0, 0.9)\n        this.metrics.miss_rate = this.calculateMovingAverage(this.metrics.miss_rate, 1, 0.9)\n        break\n        \n      case 'eviction':\n        this.metrics.eviction_rate += 1\n        break\n    }\n  }\n\n  private calculateMovingAverage(current: number, newValue: number, alpha: number): number {\n    return alpha * current + (1 - alpha) * newValue\n  }\n\n  private updateEntryCount(): void {\n    this.metrics.entry_count = this.memoryCache.size\n  }\n\n  private updateMemoryUsage(): void {\n    // Rough estimation of memory usage\n    let totalSize = 0\n    \n    for (const entry of this.memoryCache.values()) {\n      // Estimate JSON size\n      totalSize += JSON.stringify(entry).length * 2 // Unicode characters\n    }\n    \n    this.metrics.memory_usage = totalSize\n  }\n\n  private updatePopularKeys(): void {\n    const entries = Array.from(this.memoryCache.values())\n    const sorted = entries.sort((a, b) => b.hit_count - a.hit_count)\n    this.metrics.popular_keys = sorted.slice(0, 10).map(e => e.key)\n  }\n\n  private patternToRegex(pattern: string): RegExp {\n    // Convert cache pattern to regex\n    // Support * for wildcard matching\n    const regexPattern = pattern\n      .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // Escape special chars\n      .replace(/\\\\\\*/g, '.*') // Convert * to .*\n    \n    return new RegExp(`^${regexPattern}$`)\n  }\n\n  private getInvalidationPatterns(update: RealTimeUpdate): string[] {\n    const patterns: string[] = []\n    \n    switch (update.type) {\n      case 'user_interaction':\n        if (update.user_id) {\n          patterns.push(`user:${update.user_id}:*`)\n          patterns.push(`recommendations:${update.user_id}:*`)\n        }\n        break\n        \n      case 'preference_change':\n        if (update.user_id) {\n          patterns.push(`user:${update.user_id}:*`)\n          patterns.push(`profile:${update.user_id}:*`)\n        }\n        break\n        \n      case 'new_event':\n        if (update.event_id) {\n          patterns.push(`event:${update.event_id}:*`)\n          patterns.push(`recommendations:*:*`) // Broad invalidation for new events\n        }\n        break\n        \n      case 'cache_invalidation':\n        if (update.data.pattern) {\n          patterns.push(update.data.pattern)\n        }\n        break\n    }\n    \n    return patterns\n  }\n\n  private async initializeRedis(config: any): Promise<void> {\n    try {\n      // Initialize Redis client\n      // This would use actual Redis client library\n      console.log('Redis cache initialized with config:', config)\n      \n      // Mock Redis client for demonstration\n      this.redisClient = {\n        get: async (key: string) => null,\n        set: async (key: string, value: string) => 'OK',\n        setex: async (key: string, ttl: number, value: string) => 'OK',\n        del: async (...keys: string[]) => keys.length,\n        mget: async (...keys: string[]) => new Array(keys.length).fill(null),\n        keys: async (pattern: string) => [],\n        flushall: async () => 'OK',\n        ping: async () => 'PONG',\n        pipeline: () => ({\n          setex: () => {},\n          exec: async () => []\n        })\n      }\n      \n    } catch (error) {\n      console.error('Redis initialization error:', error)\n      this.enableRedis = false\n    }\n  }\n\n  private startCleanupTimer(): void {\n    // Clean up expired entries every 5 minutes\n    setInterval(() => {\n      this.cleanupExpiredEntries()\n    }, 5 * 60 * 1000)\n  }\n\n  private cleanupExpiredEntries(): void {\n    const now = Date.now()\n    const expiredKeys: string[] = []\n    \n    for (const [key, entry] of this.memoryCache.entries()) {\n      if (this.isExpired(entry)) {\n        expiredKeys.push(key)\n      }\n    }\n    \n    for (const key of expiredKeys) {\n      this.delete(key)\n    }\n    \n    if (expiredKeys.length > 0) {\n      console.log(`Cleaned up ${expiredKeys.length} expired cache entries`)\n    }\n  }\n\n  /**\n   * Create cache key from components\n   */\n  static createKey(components: (string | number | boolean)[]): string {\n    return components\n      .map(c => String(c))\n      .join(':')\n      .replace(/[^a-zA-Z0-9:_-]/g, '_') // Sanitize key\n  }\n\n  /**\n   * Create versioned cache key\n   */\n  static createVersionedKey(baseKey: string, version: string): string {\n    return `${baseKey}:v${version}`\n  }\n}