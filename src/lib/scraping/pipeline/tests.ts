// Test suite for the SceneScout Data Processing Pipeline

import { 
  DataProcessor,
  DataCleaner,
  EventNormalizer,
  GeocodingService,
  CategoryClassifier,
  QualityScorer,
  createDataProcessor,
  createPipelineComponents
} from './index';

// Test data
const sampleRawEvent = {
  title: '<h1>Test Concert Event</h1>',
  description: 'A great music event with live bands and food trucks. Email us at info@test.com or call (555) 123-4567',
  startDate: '2024-12-25T19:00:00Z',
  endDate: '2024-12-25T23:00:00Z',
  venue: 'Test Music Venue',
  address: '123 Music Street, Austin, TX 78701',
  price: 25.50,
  priceText: '$25.50 advance, $30 at door',
  website: 'https://testmusicvenue.com',
  email: 'info@test.com',
  phone: '(555) 123-4567',
  images: [
    'https://example.com/image1.jpg',
    'https://example.com/image2.png'
  ],
  tags: ['music', 'concert', 'live', 'outdoor'],
  sourceUrl: 'https://eventsource.com/test-concert',
  externalId: 'test-concert-2024'
};

const invalidEvent = {
  title: '', // Invalid: empty title
  description: 'Event with issues',
  startDate: 'invalid-date', // Invalid: bad date format
  endDate: '2024-12-20T19:00:00Z', // Invalid: end before start
  venue: null,
  address: '',
  price: -10, // Invalid: negative price
  website: 'not-a-url', // Invalid: bad URL
  email: 'bad-email', // Invalid: bad email format
  images: ['not-a-url', 123] // Invalid: bad URLs and non-string
};

// Test utilities
export class TestRunner {
  private tests: Array<{
    name: string;
    fn: () => Promise<void>;
  }> = [];

  private passed = 0;
  private failed = 0;

  add(name: string, testFn: () => Promise<void>) {
    this.tests.push({ name, fn: testFn });
  }

  async run(): Promise<void> {
    console.log(`Running ${this.tests.length} tests...\\n`);\n\n    for (const test of this.tests) {\n      try {\n        await test.fn();\n        console.log(`‚úÖ ${test.name}`);\n        this.passed++;\n      } catch (error) {\n        console.log(`‚ùå ${test.name}`);\n        console.log(`   Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.failed++;\n      }\n    }\n\n    console.log(`\\nüìä Test Results: ${this.passed} passed, ${this.failed} failed`);\n  }\n\n  assert(condition: boolean, message: string) {\n    if (!condition) {\n      throw new Error(`Assertion failed: ${message}`);\n    }\n  }\n\n  assertEqual<T>(actual: T, expected: T, message?: string) {\n    if (actual !== expected) {\n      throw new Error(`Expected ${expected}, got ${actual}${message ? `: ${message}` : ''}`);\n    }\n  }\n\n  assertNotNull<T>(value: T | null | undefined, message?: string) {\n    if (value === null || value === undefined) {\n      throw new Error(`Expected non-null value${message ? `: ${message}` : ''}`);\n    }\n  }\n\n  assertArrayLength<T>(array: T[], expectedLength: number, message?: string) {\n    if (array.length !== expectedLength) {\n      throw new Error(`Expected array length ${expectedLength}, got ${array.length}${message ? `: ${message}` : ''}`);\n    }\n  }\n\n  assertInRange(value: number, min: number, max: number, message?: string) {\n    if (value < min || value > max) {\n      throw new Error(`Expected value between ${min} and ${max}, got ${value}${message ? `: ${message}` : ''}`);\n    }\n  }\n}\n\n// DataCleaner Tests\nexport async function testDataCleaner() {\n  const runner = new TestRunner();\n\n  runner.add('should clean valid data successfully', async () => {\n    const cleaner = new DataCleaner();\n    const result = await cleaner.clean(sampleRawEvent);\n    \n    runner.assert(result.isValid, 'Should validate clean data');\n    runner.assertEqual(result.data.title, 'Test Concert Event', 'Should remove HTML tags');\n    runner.assertNotNull(result.data.startDate, 'Should preserve valid dates');\n    runner.assert(result.errors.length === 0, 'Should have no errors for valid data');\n  });\n\n  runner.add('should handle invalid data gracefully', async () => {\n    const cleaner = new DataCleaner();\n    const result = await cleaner.clean(invalidEvent);\n    \n    runner.assert(!result.isValid, 'Should fail validation for invalid data');\n    runner.assert(result.errors.length > 0, 'Should report validation errors');\n    runner.assert(result.errors.some(e => e.field === 'title'), 'Should report missing title');\n  });\n\n  runner.add('should extract price from text', async () => {\n    const cleaner = new DataCleaner();\n    const testData = { ...sampleRawEvent, price: undefined, priceText: '$15.99' };\n    const result = await cleaner.clean(testData);\n    \n    runner.assertNotNull(result.data.price, 'Should extract numeric price from text');\n  });\n\n  runner.add('should validate email addresses', async () => {\n    const cleaner = new DataCleaner({ validateEmail: true });\n    const testData = { ...sampleRawEvent, email: 'invalid-email' };\n    const result = await cleaner.clean(testData);\n    \n    runner.assert(result.errors.some(e => e.field === 'email'), 'Should report invalid email');\n  });\n\n  await runner.run();\n}\n\n// EventNormalizer Tests\nexport async function testEventNormalizer() {\n  const runner = new TestRunner();\n\n  runner.add('should normalize dates correctly', async () => {\n    const normalizer = new EventNormalizer();\n    const result = await normalizer.normalize(sampleRawEvent);\n    \n    runner.assertNotNull(result.event.normalizedStartDate, 'Should normalize start date');\n    runner.assertNotNull(result.event.normalizedEndDate, 'Should normalize end date');\n    runner.assertInRange(result.confidence, 0, 1, 'Confidence should be between 0 and 1');\n  });\n\n  runner.add('should normalize price and currency', async () => {\n    const normalizer = new EventNormalizer();\n    const result = await normalizer.normalize(sampleRawEvent);\n    \n    runner.assertEqual(result.event.normalizedPrice, 25.5, 'Should normalize price');\n    runner.assertEqual(result.event.normalizedCurrency, 'USD', 'Should default to USD currency');\n  });\n\n  runner.add('should parse location information', async () => {\n    const normalizer = new EventNormalizer();\n    const result = await normalizer.normalize(sampleRawEvent);\n    \n    runner.assertNotNull(result.event.normalizedLocation, 'Should normalize location');\n    runner.assert(\n      result.event.normalizedLocation!.address.includes('Austin'),\n      'Should preserve location information'\n    );\n  });\n\n  runner.add('should categorize events', async () => {\n    const normalizer = new EventNormalizer();\n    const result = await normalizer.normalize(sampleRawEvent);\n    \n    runner.assertNotNull(result.event.normalizedCategories, 'Should assign categories');\n    runner.assert(\n      result.event.normalizedCategories!.includes('music'),\n      'Should categorize music event correctly'\n    );\n  });\n\n  await runner.run();\n}\n\n// GeocodingService Tests\nexport async function testGeocodingService() {\n  const runner = new TestRunner();\n\n  runner.add('should geocode valid address', async () => {\n    const geocoder = new GeocodingService({\n      cacheEnabled: false // Disable cache for testing\n    });\n    \n    const result = await geocoder.geocode('Austin, TX');\n    \n    runner.assertInRange(result.confidence, 0, 1, 'Should have valid confidence');\n    \n    if (result.coordinates) {\n      runner.assertInRange(result.coordinates.latitude, 30, 31, 'Austin latitude should be ~30.3');\n      runner.assertInRange(result.coordinates.longitude, -98, -97, 'Austin longitude should be ~-97.7');\n    }\n  });\n\n  runner.add('should handle invalid address gracefully', async () => {\n    const geocoder = new GeocodingService();\n    const result = await geocoder.geocode('Invalid Address XYZ123');\n    \n    runner.assertInRange(result.confidence, 0, 1, 'Should have valid confidence range');\n    runner.assertEqual(result.source, 'fallback', 'Should use fallback for invalid address');\n  });\n\n  runner.add('should use cache when enabled', async () => {\n    const geocoder = new GeocodingService({ cacheEnabled: true });\n    \n    // First request\n    const result1 = await geocoder.geocode('New York, NY');\n    \n    // Second request (should use cache)\n    const result2 = await geocoder.geocode('New York, NY');\n    \n    runner.assertEqual(result2.source, 'cache', 'Should use cache for repeated requests');\n  });\n\n  await runner.run();\n}\n\n// CategoryClassifier Tests\nexport async function testCategoryClassifier() {\n  const runner = new TestRunner();\n\n  runner.add('should classify music event correctly', async () => {\n    const classifier = new CategoryClassifier({\n      fallbackToRuleBased: true // Ensure we get results even without OpenAI\n    });\n    \n    const result = await classifier.classify({\n      title: 'Live Jazz Concert',\n      description: 'Amazing jazz performance with live band',\n      venue: 'Jazz Club'\n    });\n    \n    runner.assertInRange(result.confidence, 0, 1, 'Should have valid confidence');\n    runner.assert(result.categories.length > 0, 'Should assign at least one category');\n    runner.assert(\n      result.categories.includes('music'),\n      'Should classify as music event'\n    );\n  });\n\n  runner.add('should extract relevant tags', async () => {\n    const classifier = new CategoryClassifier();\n    \n    const result = await classifier.classify({\n      title: 'Food and Wine Festival',\n      description: 'Taste amazing food from local restaurants and wine from vineyards'\n    });\n    \n    runner.assert(result.tags.length > 0, 'Should extract tags');\n    runner.assert(\n      result.tags.some(tag => ['food', 'wine', 'festival'].includes(tag)),\n      'Should extract relevant food/wine tags'\n    );\n  });\n\n  runner.add('should handle empty input gracefully', async () => {\n    const classifier = new CategoryClassifier();\n    \n    const result = await classifier.classify({\n      title: '',\n      description: ''\n    });\n    \n    runner.assertInRange(result.confidence, 0, 1, 'Should handle empty input');\n  });\n\n  await runner.run();\n}\n\n// QualityScorer Tests\nexport async function testQualityScorer() {\n  const runner = new TestRunner();\n\n  runner.add('should score complete event highly', async () => {\n    const scorer = new QualityScorer();\n    const score = await scorer.scoreEvent(sampleRawEvent);\n    \n    runner.assertInRange(score.overall, 0, 1, 'Overall score should be between 0 and 1');\n    runner.assertInRange(score.metrics.completeness, 0.7, 1, 'Complete event should score well on completeness');\n    runner.assert(['premium', 'standard', 'basic', 'poor'].includes(score.tier), 'Should assign valid tier');\n  });\n\n  runner.add('should score incomplete event lower', async () => {\n    const scorer = new QualityScorer();\n    const incompleteEvent = {\n      title: 'Basic Event',\n      startDate: '2024-12-25T19:00:00Z'\n    };\n    \n    const score = await scorer.scoreEvent(incompleteEvent);\n    \n    runner.assertInRange(score.overall, 0, 1, 'Should have valid overall score');\n    runner.assert(score.metrics.completeness < 0.5, 'Incomplete event should have low completeness');\n    runner.assert(score.recommendations.length > 0, 'Should provide recommendations for improvement');\n  });\n\n  runner.add('should include quality breakdown when enabled', async () => {\n    const scorer = new QualityScorer({ includeBreakdown: true });\n    const score = await scorer.scoreEvent(sampleRawEvent);\n    \n    runner.assertNotNull(score.breakdown, 'Should include breakdown');\n    runner.assert('completeness' in score.breakdown, 'Should include completeness breakdown');\n    runner.assert('accuracy' in score.breakdown, 'Should include accuracy breakdown');\n  });\n\n  runner.add('should generate helpful recommendations', async () => {\n    const scorer = new QualityScorer({ includeRecommendations: true });\n    const incompleteEvent = {\n      title: 'Event',\n      // Missing description, venue, images\n    };\n    \n    const score = await scorer.scoreEvent(incompleteEvent);\n    \n    runner.assert(score.recommendations.length > 0, 'Should provide recommendations');\n    runner.assert(\n      score.recommendations.some(r => r.includes('description')),\n      'Should recommend adding description'\n    );\n  });\n\n  await runner.run();\n}\n\n// DataProcessor Integration Tests\nexport async function testDataProcessor() {\n  const runner = new TestRunner();\n\n  runner.add('should process valid event successfully', async () => {\n    const processor = createDataProcessor({\n      saveToDatabase: false, // Skip database for testing\n      skipSteps: ['imageProcessing'] // Skip expensive operations\n    });\n    \n    const result = await processor.processEvent(sampleRawEvent);\n    \n    runner.assert(result.success, 'Should process valid event successfully');\n    runner.assertNotNull(result.event.qualityScore, 'Should assign quality score');\n    runner.assertNotNull(result.event.categories, 'Should assign categories');\n    runner.assert(result.processingTime > 0, 'Should track processing time');\n  });\n\n  runner.add('should handle invalid event gracefully', async () => {\n    const processor = createDataProcessor({\n      saveToDatabase: false,\n      failOnError: false // Don't fail on errors\n    });\n    \n    const result = await processor.processEvent(invalidEvent);\n    \n    runner.assert(!result.success, 'Should report failure for invalid event');\n    runner.assert(result.errors.length > 0, 'Should report errors');\n    runner.assertNotNull(result.event, 'Should still return event object');\n  });\n\n  runner.add('should process batch of events', async () => {\n    const processor = createDataProcessor({\n      saveToDatabase: false,\n      batchSize: 2,\n      maxConcurrent: 2\n    });\n    \n    const events = [sampleRawEvent, { ...sampleRawEvent, title: 'Event 2' }];\n    const result = await processor.batchProcess(events);\n    \n    runner.assertEqual(result.summary.total, 2, 'Should process all events in batch');\n    runner.assert(result.summary.successful > 0, 'Should have some successful results');\n    runner.assertArrayLength(result.results, 2, 'Should return result for each event');\n  });\n\n  runner.add('should skip specified steps', async () => {\n    const processor = createDataProcessor({\n      saveToDatabase: false,\n      skipSteps: ['geocoding', 'classification', 'imageProcessing']\n    });\n    \n    const result = await processor.processEvent(sampleRawEvent);\n    \n    runner.assert(result.skippedSteps.includes('geocoding'), 'Should skip geocoding');\n    runner.assert(result.skippedSteps.includes('classification'), 'Should skip classification');\n    runner.assert(result.skippedSteps.includes('imageProcessing'), 'Should skip image processing');\n  });\n\n  runner.add('should validate input before processing', async () => {\n    const processor = createDataProcessor();\n    \n    const validation = await processor.validateInput(null);\n    runner.assert(!validation.valid, 'Should reject null input');\n    \n    const validation2 = await processor.validateInput({ title: 'Valid Event' });\n    runner.assert(validation2.valid, 'Should accept valid input');\n  });\n\n  await runner.run();\n}\n\n// Component Integration Tests\nexport async function testPipelineIntegration() {\n  const runner = new TestRunner();\n\n  runner.add('should create components with factory function', async () => {\n    const components = createPipelineComponents({\n      cleaning: { removeHtml: true },\n      normalization: { defaultTimezone: 'UTC' }\n    });\n    \n    runner.assertNotNull(components.dataCleaner, 'Should create data cleaner');\n    runner.assertNotNull(components.eventNormalizer, 'Should create event normalizer');\n    runner.assertNotNull(components.geocodingService, 'Should create geocoding service');\n    runner.assertNotNull(components.categoryClassifier, 'Should create category classifier');\n    runner.assertNotNull(components.imageProcessor, 'Should create image processor');\n    runner.assertNotNull(components.qualityScorer, 'Should create quality scorer');\n  });\n\n  runner.add('should process data through complete pipeline', async () => {\n    const components = createPipelineComponents();\n    let eventData = sampleRawEvent;\n    \n    // Step 1: Clean\n    const cleanResult = await components.dataCleaner.clean(eventData);\n    runner.assert(cleanResult.isValid, 'Cleaning should succeed');\n    eventData = { ...eventData, ...cleanResult.data };\n    \n    // Step 2: Normalize\n    const normalizeResult = await components.eventNormalizer.normalize(eventData);\n    runner.assertInRange(normalizeResult.confidence, 0, 1, 'Normalization should have valid confidence');\n    eventData = { ...eventData, ...normalizeResult.event };\n    \n    // Step 3: Classify\n    const classifyResult = await components.categoryClassifier.classify({\n      title: eventData.title || '',\n      description: eventData.description,\n      venue: eventData.venue\n    });\n    runner.assert(classifyResult.categories.length > 0, 'Classification should assign categories');\n    \n    // Step 4: Score\n    const scoreResult = await components.qualityScorer.scoreEvent(eventData);\n    runner.assertInRange(scoreResult.overall, 0, 1, 'Scoring should produce valid score');\n    \n    console.log('   ‚úì Complete pipeline processing successful');\n  });\n\n  await runner.run();\n}\n\n// Performance Tests\nexport async function testPerformance() {\n  const runner = new TestRunner();\n\n  runner.add('should process single event within reasonable time', async () => {\n    const processor = createDataProcessor({\n      saveToDatabase: false,\n      skipSteps: ['imageProcessing'] // Skip slow operations\n    });\n    \n    const startTime = Date.now();\n    const result = await processor.processEvent(sampleRawEvent);\n    const processingTime = Date.now() - startTime;\n    \n    runner.assert(processingTime < 10000, 'Should process event in under 10 seconds');\n    runner.assert(result.processingTime < processingTime * 1.1, 'Reported time should be accurate');\n  });\n\n  runner.add('should handle moderate batch size efficiently', async () => {\n    const processor = createDataProcessor({\n      saveToDatabase: false,\n      batchSize: 5,\n      maxConcurrent: 3,\n      skipSteps: ['imageProcessing']\n    });\n    \n    const events = Array.from({ length: 10 }, (_, i) => ({\n      ...sampleRawEvent,\n      title: `Test Event ${i + 1}`,\n      externalId: `test-${i + 1}`\n    }));\n    \n    const startTime = Date.now();\n    const result = await processor.batchProcess(events);\n    const totalTime = Date.now() - startTime;\n    const avgTimePerEvent = totalTime / events.length;\n    \n    runner.assert(avgTimePerEvent < 5000, 'Should average under 5 seconds per event');\n    runner.assertEqual(result.summary.total, 10, 'Should process all events');\n  });\n\n  await runner.run();\n}\n\n// Main test runner\nexport async function runAllTests() {\n  console.log('üß™ SceneScout Data Processing Pipeline Test Suite\\n');\n  console.log('=' .repeat(60));\n\n  const testSuites = [\n    { name: 'DataCleaner Tests', fn: testDataCleaner },\n    { name: 'EventNormalizer Tests', fn: testEventNormalizer },\n    { name: 'GeocodingService Tests', fn: testGeocodingService },\n    { name: 'CategoryClassifier Tests', fn: testCategoryClassifier },\n    { name: 'QualityScorer Tests', fn: testQualityScorer },\n    { name: 'DataProcessor Tests', fn: testDataProcessor },\n    { name: 'Pipeline Integration Tests', fn: testPipelineIntegration },\n    { name: 'Performance Tests', fn: testPerformance }\n  ];\n\n  let totalPassed = 0;\n  let totalFailed = 0;\n\n  for (const suite of testSuites) {\n    console.log(`\\nüìã ${suite.name}`);\n    console.log('-'.repeat(40));\n    \n    try {\n      await suite.fn();\n    } catch (error) {\n      console.log(`‚ùå Test suite failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      totalFailed++;\n    }\n  }\n\n  console.log('\\n' + '='.repeat(60));\n  console.log('üèÅ All test suites completed');\n  console.log('\\nüí° Note: Some tests may fail if external services (OpenAI, geocoding) are not configured');\n  console.log('   This is expected in testing environments without API keys.');\n}\n\n// Export all test functions\nexport const tests = {\n  testDataCleaner,\n  testEventNormalizer,\n  testGeocodingService,\n  testCategoryClassifier,\n  testQualityScorer,\n  testDataProcessor,\n  testPipelineIntegration,\n  testPerformance,\n  runAllTests,\n  TestRunner\n};"