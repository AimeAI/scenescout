/**\n * Example usage and integration patterns for the Intelligent Deduplication System\n * These examples demonstrate common use cases and best practices\n */\n\nimport { Event } from '@/types'\nimport {\n  IntelligentDeduplicationSystem,\n  createDeduplicationSystem,\n  quickDuplicateCheck,\n  batchProcessEvents,\n  FuzzyMatcher,\n  MergeStrategy,\n  ProcessingMode\n} from './index'\n\n// Example events for demonstration\nconst sampleEvents = {\n  jazzConcert: {\n    id: 'event-1',\n    title: 'Jazz Night at Blue Note',\n    description: 'An evening of smooth jazz featuring local artists',\n    venue_name: 'Blue Note Jazz Club',\n    city_name: 'New York',\n    start_time: '2024-02-15T20:00:00Z',\n    end_time: '2024-02-15T23:00:00Z',\n    category: 'music',\n    price_min: 25,\n    price_max: 45,\n    latitude: 40.7128,\n    longitude: -74.0060,\n    website_url: 'https://bluenotejazz.com',\n    source: 'manual',\n    tags: ['jazz', 'live music', 'evening'],\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-01T00:00:00Z'\n  } as Event,\n\n  jazzConcertDuplicate: {\n    id: 'event-2',\n    title: 'Jazz Evening at Blue Note Club',\n    description: 'Amazing jazz night with talented local musicians',\n    venue_name: 'Blue Note',\n    city_name: 'New York',\n    start_time: '2024-02-15T20:00:00Z',\n    category: 'music',\n    price_min: 30,\n    price_max: 50,\n    latitude: 40.7129,\n    longitude: -74.0061,\n    ticket_url: 'https://eventbrite.com/jazz-night',\n    source: 'eventbrite',\n    external_id: 'eb-12345',\n    tags: ['jazz', 'music'],\n    created_at: '2024-01-02T00:00:00Z',\n    updated_at: '2024-01-02T00:00:00Z'\n  } as Event\n}\n\n/**\n * Example 1: Basic Duplicate Detection\n * Demonstrates simple duplicate checking with default configuration\n */\nexport async function basicDuplicateDetection() {\n  console.log('=== Basic Duplicate Detection Example ===')\n  \n  // Create system with default configuration\n  const system = createDeduplicationSystem()\n  await system.initialize()\n  \n  try {\n    // Check for duplicates\n    const result = await system.checkForDuplicates(\n      sampleEvents.jazzConcert,\n      [sampleEvents.jazzConcertDuplicate]\n    )\n    \n    console.log('Duplicate detection result:')\n    console.log(`- Is duplicate: ${result.isDuplicate}`)\n    console.log(`- Confidence: ${(result.confidence * 100).toFixed(1)}%`)\n    console.log(`- Matches found: ${result.matches.length}`)\n    \n    if (result.matches.length > 0) {\n      const match = result.matches[0]\n      console.log(`\\nMatch details:`)\n      console.log(`- Event ID: ${match.eventId}`)\n      console.log(`- Confidence: ${(match.confidence * 100).toFixed(1)}%`)\n      console.log(`- Reasons: ${match.reasons.join(', ')}`)\n      console.log(`- Similarity scores:`, {\n        title: (match.similarityScore.title * 100).toFixed(1) + '%',\n        venue: (match.similarityScore.venue * 100).toFixed(1) + '%',\n        location: (match.similarityScore.location * 100).toFixed(1) + '%',\n        overall: (match.similarityScore.overall * 100).toFixed(1) + '%'\n      })\n    }\n    \n  } catch (error) {\n    console.error('Error in duplicate detection:', error)\n  } finally {\n    system.cleanup()\n  }\n}\n\n/**\n * Example 2: Advanced Configuration\n * Shows how to customize the system for specific requirements\n */\nexport async function advancedConfiguration() {\n  console.log('\\n=== Advanced Configuration Example ===')\n  \n  // Create system with custom configuration\n  const system = new IntelligentDeduplicationSystem({\n    thresholds: {\n      title: 0.85,      // Higher title similarity requirement\n      venue: 0.75,      // Lower venue similarity requirement\n      location: 0.80,   // Higher location accuracy requirement\n      date: 0.95,       // Very strict date matching\n      semantic: 0.70,   // Moderate semantic matching\n      overall: 0.82     // Higher overall threshold\n    },\n    weights: {\n      title: 0.40,      // Increase title importance\n      venue: 0.30,      // Increase venue importance\n      location: 0.20,   // Standard location weight\n      date: 0.08,       // Reduce date weight slightly\n      semantic: 0.02    // Reduce semantic weight\n    },\n    algorithms: {\n      stringMatching: 'jaro_winkler',  // Use Jaro-Winkler for better name matching\n      semanticMatching: true,          // Enable semantic analysis\n      locationMatching: 'hybrid',      // Use hybrid location matching\n      fuzzyDate: false                 // Disable fuzzy date matching for strict timing\n    },\n    performance: {\n      batchSize: 50,                   // Smaller batches for memory efficiency\n      maxCandidates: 30,               // Limit candidates for speed\n      enableCaching: true,             // Enable caching\n      parallelProcessing: true         // Enable parallel processing\n    },\n    quality: {\n      minimumQualityScore: 0.75,       // Higher quality requirement\n      requireManualReview: true,       // Require manual review\n      autoMergeThreshold: 0.95         // Very high auto-merge threshold\n    }\n  })\n  \n  await system.initialize()\n  \n  try {\n    // Test with custom configuration\n    const result = await system.checkForDuplicates(\n      sampleEvents.jazzConcert,\n      [sampleEvents.jazzConcertDuplicate]\n    )\n    \n    console.log('Custom configuration result:')\n    console.log(`- Is duplicate: ${result.isDuplicate}`)\n    console.log(`- Confidence: ${(result.confidence * 100).toFixed(1)}%`)\n    console.log(`- Processing time: ${result.metadata.processingTime}ms`)\n    console.log(`- Algorithms used: ${result.metadata.algorithmsUsed.join(', ')}`)\n    \n    // Show current configuration\n    const config = system.getConfiguration()\n    console.log('\\nCurrent thresholds:', config.thresholds)\n    console.log('Current weights:', config.weights)\n    \n  } catch (error) {\n    console.error('Error with custom configuration:', error)\n  } finally {\n    system.cleanup()\n  }\n}\n\n/**\n * Example 3: Event Merging and Conflict Resolution\n * Demonstrates how to merge duplicate events intelligently\n */\nexport async function eventMergingExample() {\n  console.log('\\n=== Event Merging Example ===')\n  \n  const system = createDeduplicationSystem()\n  await system.initialize()\n  \n  try {\n    // Create merge decision\n    const decision = system.createMergeDecision(\n      sampleEvents.jazzConcert,           // Primary event\n      [sampleEvents.jazzConcertDuplicate], // Duplicate events\n      'enhance_primary'                    // Merge strategy\n    )\n    \n    console.log('Merge decision created:')\n    console.log(`- Primary event: ${decision.primaryEventId}`)\n    console.log(`- Duplicate events: ${decision.duplicateEventIds.join(', ')}`)\n    console.log(`- Strategy: ${decision.strategy}`)\n    console.log(`- Confidence: ${(decision.confidence * 100).toFixed(1)}%`)\n    console.log(`- Field resolutions: ${decision.fieldResolutions.length}`)\n    \n    // Show some field resolutions\n    console.log('\\nField resolution examples:')\n    decision.fieldResolutions.slice(0, 5).forEach(resolution => {\n      console.log(`- ${resolution.field}: ${resolution.strategy} (confidence: ${(resolution.confidence * 100).toFixed(1)}%)`)\n    })\n    \n    // Execute merge\n    const mergeResult = await system.executeMerge(decision, 'example-user')\n    \n    if (mergeResult.success) {\n      console.log('\\nMerge executed successfully!')\n      console.log(`- Merge history ID: ${mergeResult.historyId}`)\n      console.log(`- Enhanced fields: ${mergeResult.mergedEvent.title}`)\n      \n      // Show improvements\n      const original = sampleEvents.jazzConcert\n      const merged = mergeResult.mergedEvent\n      \n      console.log('\\nMerge improvements:')\n      if (merged.ticket_url && !original.ticket_url) {\n        console.log(`- Added ticket URL: ${merged.ticket_url}`)\n      }\n      if (merged.description && merged.description.length > (original.description?.length || 0)) {\n        console.log(`- Enhanced description (${merged.description.length} vs ${original.description?.length || 0} chars)`)\n      }\n      \n    } else {\n      console.error('Merge failed:', mergeResult.errors)\n    }\n    \n  } catch (error) {\n    console.error('Error in merging example:', error)\n  } finally {\n    system.cleanup()\n  }\n}\n\n/**\n * Example 4: Batch Processing\n * Shows how to process multiple events efficiently\n */\nexport async function batchProcessingExample() {\n  console.log('\\n=== Batch Processing Example ===')\n  \n  // Generate sample dataset\n  const events: Event[] = [\n    sampleEvents.jazzConcert,\n    sampleEvents.jazzConcertDuplicate,\n    {\n      id: 'event-3',\n      title: 'Rock Concert at Madison Square Garden',\n      venue_name: 'Madison Square Garden',\n      city_name: 'New York',\n      start_time: '2024-02-20T19:00:00Z',\n      category: 'music',\n      source: 'primary'\n    } as Event,\n    {\n      id: 'event-4',\n      title: 'Jazz at Blue Note', // Another potential duplicate\n      venue_name: 'Blue Note Jazz Club',\n      city_name: 'New York',\n      start_time: '2024-02-15T20:30:00Z', // Slightly different time\n      category: 'music',\n      source: 'meetup'\n    } as Event\n  ]\n  \n  try {\n    console.log(`Processing ${events.length} events...`)\n    const startTime = Date.now()\n    \n    // Process in batch mode\n    const result = await batchProcessEvents(events, 'batch')\n    \n    const processingTime = Date.now() - startTime\n    \n    console.log('Batch processing results:')\n    console.log(`- Events processed: ${result.processedCount}`)\n    console.log(`- Duplicates found: ${result.duplicatesFound}`)\n    console.log(`- Merges completed: ${result.mergesCompleted}`)\n    console.log(`- Processing time: ${processingTime}ms`)\n    console.log(`- Errors: ${result.errors.length}`)\n    \n    // Show performance metrics\n    console.log('\\nPerformance metrics:')\n    console.log(`- Average time per event: ${(result.performance.processingTime / result.processedCount).toFixed(2)}ms`)\n    console.log(`- Quality improvement: ${(result.performance.qualityImprovement * 100).toFixed(1)}%`)\n    \n    if (result.errors.length > 0) {\n      console.log('\\nErrors encountered:')\n      result.errors.forEach(error => {\n        console.log(`- Event ${error.eventId}: ${error.error}`)\n      })\n    }\n    \n  } catch (error) {\n    console.error('Error in batch processing:', error)\n  }\n}\n\n/**\n * Example 5: Real-time Processing\n * Demonstrates real-time duplicate detection for incoming events\n */\nexport async function realtimeProcessingExample() {\n  console.log('\\n=== Real-time Processing Example ===')\n  \n  const system = createDeduplicationSystem({\n    performance: {\n      batchSize: 1,           // Process one at a time\n      enableCaching: true,    // Enable caching for speed\n      parallelProcessing: false // Disable parallel processing for real-time\n    }\n  })\n  \n  await system.initialize()\n  \n  // Simulate existing events in database\n  const existingEvents = [sampleEvents.jazzConcert]\n  \n  // Simulate incoming events stream\n  const incomingEvents = [\n    sampleEvents.jazzConcertDuplicate,\n    {\n      id: 'event-new-1',\n      title: 'Classical Concert at Carnegie Hall',\n      venue_name: 'Carnegie Hall',\n      city_name: 'New York',\n      start_time: '2024-03-01T19:30:00Z',\n      category: 'music',\n      source: 'ticketmaster'\n    } as Event\n  ]\n  \n  try {\n    console.log('Processing incoming events in real-time...')\n    \n    for (const incomingEvent of incomingEvents) {\n      console.log(`\\nProcessing: ${incomingEvent.title}`)\n      const startTime = Date.now()\n      \n      // Quick duplicate check\n      const { isDuplicate, matches } = await quickDuplicateCheck(\n        incomingEvent,\n        existingEvents,\n        0.8 // 80% threshold\n      )\n      \n      const processingTime = Date.now() - startTime\n      \n      if (isDuplicate) {\n        console.log(`✓ Duplicate detected in ${processingTime}ms`)\n        console.log(`  - Matches: ${matches.length}`)\n        console.log(`  - Best match confidence: ${(matches[0].confidence * 100).toFixed(1)}%`)\n        \n        // In real implementation, you would merge or update existing event\n        console.log('  → Would merge with existing event')\n        \n      } else {\n        console.log(`✓ Unique event processed in ${processingTime}ms`)\n        console.log('  → Would add as new event')\n        \n        // Add to existing events for next iteration\n        existingEvents.push(incomingEvent)\n      }\n    }\n    \n  } catch (error) {\n    console.error('Error in real-time processing:', error)\n  } finally {\n    system.cleanup()\n  }\n}\n\n/**\n * Example 6: Custom Fuzzy Matcher\n * Shows how to use the FuzzyMatcher component directly\n */\nexport async function customFuzzyMatcherExample() {\n  console.log('\\n=== Custom Fuzzy Matcher Example ===')\n  \n  // Create custom matcher with specific algorithms\n  const matcher = new FuzzyMatcher({\n    algorithms: {\n      stringMatching: 'cosine',        // Use cosine similarity\n      semanticMatching: true,          // Enable semantic matching\n      locationMatching: 'coordinates'  // Use coordinate-based location matching\n    },\n    thresholds: {\n      title: 0.7,\n      venue: 0.6,\n      overall: 0.75\n    },\n    performance: {\n      enableCaching: true\n    }\n  })\n  \n  try {\n    // Generate fingerprints\n    const fp1 = matcher.generateFingerprint(sampleEvents.jazzConcert)\n    const fp2 = matcher.generateFingerprint(sampleEvents.jazzConcertDuplicate)\n    \n    console.log('Event fingerprints generated:')\n    console.log(`Event 1 - Title tokens: [${fp1.titleTokens.join(', ')}]`)\n    console.log(`Event 1 - Venue: \"${fp1.venueNormalized}\"`)\n    console.log(`Event 1 - Location key: \"${fp1.locationKey}\"`)\n    console.log(`Event 1 - Date key: \"${fp1.dateKey}\"`)\n    \n    // Calculate detailed similarity\n    const similarity = matcher.calculateSimilarity(fp1, fp2)\n    \n    console.log('\\nDetailed similarity analysis:')\n    Object.entries(similarity).forEach(([metric, score]) => {\n      const percentage = (score * 100).toFixed(1)\n      const status = score > 0.7 ? '✓' : score > 0.5 ? '~' : '✗'\n      console.log(`${status} ${metric.padEnd(10)}: ${percentage}%`)\n    })\n    \n    // Find matches with detailed analysis\n    const matches = await matcher.findMatches(\n      sampleEvents.jazzConcert,\n      [sampleEvents.jazzConcertDuplicate]\n    )\n    \n    if (matches.length > 0) {\n      const match = matches[0]\n      console.log('\\nMatch analysis:')\n      console.log(`- Event: ${match.eventId}`)\n      console.log(`- Confidence: ${(match.confidence * 100).toFixed(1)}%`)\n      console.log(`- Reasons: ${match.reasons.join(', ')}`)\n      if (match.riskFactors.length > 0) {\n        console.log(`- Risk factors: ${match.riskFactors.join(', ')}`)\n      }\n    }\n    \n    // Show cache statistics\n    const cacheStats = matcher.getCacheStats()\n    console.log('\\nCache statistics:')\n    console.log(`- Similarity cache size: ${cacheStats.similarityCache.size}`)\n    console.log(`- Cache hit rate: ${(cacheStats.similarityCache.hitRate * 100).toFixed(1)}%`)\n    \n  } catch (error) {\n    console.error('Error in fuzzy matcher example:', error)\n  } finally {\n    matcher.clearCache()\n  }\n}\n\n/**\n * Example 7: Performance Monitoring and Analytics\n * Shows how to monitor system performance and generate reports\n */\nexport async function performanceMonitoringExample() {\n  console.log('\\n=== Performance Monitoring Example ===')\n  \n  const system = createDeduplicationSystem()\n  await system.initialize()\n  \n  try {\n    // Perform some operations to generate metrics\n    const events = [\n      sampleEvents.jazzConcert,\n      sampleEvents.jazzConcertDuplicate,\n      {\n        id: 'event-test-1',\n        title: 'Test Event 1',\n        category: 'test',\n        start_time: '2024-02-01T10:00:00Z',\n        source: 'test'\n      } as Event\n    ]\n    \n    await system.processEvents(events, 'batch')\n    \n    // Get performance metrics\n    const metrics = system.getPerformanceMetrics()\n    \n    console.log('System performance metrics:')\n    console.log('\\nFuzzy Matcher:')\n    console.log(`- Cache size: ${metrics.fuzzyMatcher.similarityCache.size}`)\n    console.log(`- Hit rate: ${(metrics.fuzzyMatcher.similarityCache.hitRate * 100).toFixed(1)}%`)\n    \n    console.log('\\nConflict Resolver:')\n    console.log(`- Total resolutions: ${metrics.conflictResolver.totalResolutions}`)\n    console.log(`- Manual review rate: ${(metrics.conflictResolver.manualReviewRate * 100).toFixed(1)}%`)\n    console.log(`- Average confidence: ${(metrics.conflictResolver.avgConfidence * 100).toFixed(1)}%`)\n    \n    console.log('\\nHistory Tracker:')\n    console.log(`- Total merges: ${metrics.historyTracker.totalMerges}`)\n    console.log(`- Events merged: ${metrics.historyTracker.totalEventsMerged}`)\n    console.log(`- Average confidence: ${(metrics.historyTracker.avgConfidence * 100).toFixed(1)}%`)\n    \n    // Generate comprehensive report\n    const report = await system.generateReport({\n      dateRange: {\n        start: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24 hours\n        end: new Date()\n      }\n    })\n    \n    console.log('\\nComprehensive report:')\n    console.log(`- Summary: ${report.summary.totalMerges} merges with ${(report.summary.qualityImprovement * 100).toFixed(1)}% quality improvement`)\n    console.log(`- Quality metrics: Precision ${(report.quality.precision * 100).toFixed(1)}%, Recall ${(report.quality.recall * 100).toFixed(1)}%`)\n    console.log(`- Performance: ${report.performance.processingTime}ms total, ${report.performance.eventsProcessed} events`)\n    \n    if (report.recommendations.length > 0) {\n      console.log('\\nRecommendations:')\n      report.recommendations.forEach(rec => {\n        console.log(`- ${rec}`)\n      })\n    }\n    \n    // Health check\n    const health = system.healthCheck()\n    console.log(`\\nSystem health: ${health.status}`)\n    \n    if (health.recommendations.length > 0) {\n      console.log('Health recommendations:')\n      health.recommendations.forEach(rec => {\n        console.log(`- ${rec}`)\n      })\n    }\n    \n  } catch (error) {\n    console.error('Error in performance monitoring:', error)\n  } finally {\n    system.cleanup()\n  }\n}\n\n/**\n * Example 8: Data Import/Export\n * Demonstrates how to backup and restore system data\n */\nexport async function dataImportExportExample() {\n  console.log('\\n=== Data Import/Export Example ===')\n  \n  const system = createDeduplicationSystem()\n  await system.initialize()\n  \n  try {\n    // Perform some operations to generate data\n    const decision = system.createMergeDecision(\n      sampleEvents.jazzConcert,\n      [sampleEvents.jazzConcertDuplicate],\n      'enhance_primary'\n    )\n    \n    await system.executeMerge(decision, 'export-example')\n    \n    // Export data\n    console.log('Exporting system data...')\n    const exported = system.exportData('json')\n    \n    console.log('Export completed:')\n    console.log(`- Merge history size: ${exported.mergeHistory.length} characters`)\n    console.log(`- Configuration size: ${exported.configuration.length} characters`)\n    console.log(`- Performance data size: ${exported.performance.length} characters`)\n    \n    // Show sample of exported merge history\n    const historyData = JSON.parse(exported.mergeHistory)\n    if (historyData.length > 0) {\n      console.log('\\nSample merge history entry:')\n      const sample = historyData[0]\n      console.log(`- ID: ${sample.id}`)\n      console.log(`- Primary event: ${sample.primaryEventId}`)\n      console.log(`- Strategy: ${sample.strategy}`)\n      console.log(`- Confidence: ${(sample.confidence * 100).toFixed(1)}%`)\n    }\n    \n    // Create new system and import data\n    const newSystem = createDeduplicationSystem()\n    await newSystem.initialize()\n    \n    console.log('\\nImporting data to new system...')\n    const importResult = newSystem.importData({\n      mergeHistory: exported.mergeHistory,\n      configuration: exported.configuration\n    })\n    \n    console.log('Import completed:')\n    console.log(`- Merge history imported: ${importResult.imported.mergeHistory} entries`)\n    console.log(`- Configuration imported: ${importResult.imported.configuration}`)\n    \n    if (importResult.errors.length > 0) {\n      console.log('Import errors:')\n      importResult.errors.forEach(error => {\n        console.log(`- ${error}`)\n      })\n    }\n    \n    // Verify import\n    const importedHistory = newSystem.getEventHistory(sampleEvents.jazzConcert.id)\n    console.log(`\\nVerification: Found ${importedHistory.length} history entries for event`)\n    \n    newSystem.cleanup()\n    \n  } catch (error) {\n    console.error('Error in import/export example:', error)\n  } finally {\n    system.cleanup()\n  }\n}\n\n/**\n * Example 9: Integration with Event Pipeline\n * Shows integration with typical event processing pipeline\n */\nexport async function pipelineIntegrationExample() {\n  console.log('\\n=== Pipeline Integration Example ===')\n  \n  // Simulate event pipeline components\n  class EventPipeline {\n    private deduplicationSystem: IntelligentDeduplicationSystem\n    private processedEvents: Event[] = []\n    \n    constructor() {\n      this.deduplicationSystem = createDeduplicationSystem({\n        thresholds: { overall: 0.8 },\n        performance: { batchSize: 20 }\n      })\n    }\n    \n    async initialize() {\n      await this.deduplicationSystem.initialize()\n    }\n    \n    async processIncomingEvent(event: Event): Promise<{\n      action: 'created' | 'merged' | 'skipped'\n      eventId: string\n      details?: string\n    }> {\n      try {\n        // Check for duplicates against existing events\n        const result = await this.deduplicationSystem.checkForDuplicates(\n          event,\n          this.processedEvents\n        )\n        \n        if (result.isDuplicate && result.confidence > 0.85) {\n          // High confidence duplicate - merge automatically\n          const primaryEvent = this.processedEvents.find(\n            e => e.id === result.primaryEventId\n          )\n          \n          if (primaryEvent) {\n            const decision = this.deduplicationSystem.createMergeDecision(\n              primaryEvent,\n              [event],\n              'enhance_primary'\n            )\n            \n            const mergeResult = await this.deduplicationSystem.executeMerge(\n              decision,\n              'pipeline'\n            )\n            \n            if (mergeResult.success) {\n              // Update processed events with merged event\n              const index = this.processedEvents.findIndex(\n                e => e.id === primaryEvent.id\n              )\n              this.processedEvents[index] = mergeResult.mergedEvent\n              \n              return {\n                action: 'merged',\n                eventId: primaryEvent.id,\n                details: `Merged with confidence ${(result.confidence * 100).toFixed(1)}%`\n              }\n            }\n          }\n        } else if (result.isDuplicate && result.confidence > 0.7) {\n          // Medium confidence - flag for manual review\n          return {\n            action: 'skipped',\n            eventId: event.id,\n            details: `Flagged for manual review (confidence: ${(result.confidence * 100).toFixed(1)}%)`\n          }\n        }\n        \n        // No duplicate or low confidence - add as new event\n        this.processedEvents.push(event)\n        return {\n          action: 'created',\n          eventId: event.id,\n          details: 'Added as new event'\n        }\n        \n      } catch (error) {\n        console.error('Pipeline processing error:', error)\n        return {\n          action: 'skipped',\n          eventId: event.id,\n          details: `Error: ${error.message}`\n        }\n      }\n    }\n    \n    async cleanup() {\n      this.deduplicationSystem.cleanup()\n    }\n    \n    getStats() {\n      return {\n        totalEvents: this.processedEvents.length,\n        performance: this.deduplicationSystem.getPerformanceMetrics()\n      }\n    }\n  }\n  \n  // Test the pipeline\n  const pipeline = new EventPipeline()\n  await pipeline.initialize()\n  \n  try {\n    const testEvents = [\n      sampleEvents.jazzConcert,\n      sampleEvents.jazzConcertDuplicate,\n      {\n        id: 'event-unique-1',\n        title: 'Rock Concert at Venue X',\n        venue_name: 'Venue X',\n        city_name: 'New York',\n        start_time: '2024-03-01T20:00:00Z',\n        category: 'music',\n        source: 'manual'\n      } as Event,\n      {\n        id: 'event-near-duplicate',\n        title: 'Jazz Night at Blue Note Club', // Very similar to first event\n        venue_name: 'Blue Note',\n        city_name: 'New York',\n        start_time: '2024-02-15T20:15:00Z', // Slightly different time\n        category: 'music',\n        source: 'facebook'\n      } as Event\n    ]\n    \n    console.log('Processing events through pipeline...')\n    \n    for (const event of testEvents) {\n      const result = await pipeline.processIncomingEvent(event)\n      console.log(`Event \"${event.title}\" → ${result.action} (${result.details})`)\n    }\n    \n    // Show pipeline statistics\n    const stats = pipeline.getStats()\n    console.log('\\nPipeline statistics:')\n    console.log(`- Total events processed: ${stats.totalEvents}`)\n    console.log(`- History tracker merges: ${stats.performance.historyTracker.totalMerges}`)\n    \n  } catch (error) {\n    console.error('Error in pipeline integration:', error)\n  } finally {\n    await pipeline.cleanup()\n  }\n}\n\n/**\n * Run all examples\n */\nexport async function runAllExamples() {\n  console.log('🚀 Running Intelligent Deduplication System Examples\\n')\n  \n  const examples = [\n    { name: 'Basic Duplicate Detection', fn: basicDuplicateDetection },\n    { name: 'Advanced Configuration', fn: advancedConfiguration },\n    { name: 'Event Merging', fn: eventMergingExample },\n    { name: 'Batch Processing', fn: batchProcessingExample },\n    { name: 'Real-time Processing', fn: realtimeProcessingExample },\n    { name: 'Custom Fuzzy Matcher', fn: customFuzzyMatcherExample },\n    { name: 'Performance Monitoring', fn: performanceMonitoringExample },\n    { name: 'Data Import/Export', fn: dataImportExportExample },\n    { name: 'Pipeline Integration', fn: pipelineIntegrationExample }\n  ]\n  \n  for (const example of examples) {\n    try {\n      console.log(`\\n${'='.repeat(50)}`)\n      console.log(`Running: ${example.name}`)\n      console.log('='.repeat(50))\n      \n      await example.fn()\n      \n      console.log(`\\n✅ ${example.name} completed successfully`)\n      \n    } catch (error) {\n      console.error(`❌ ${example.name} failed:`, error.message)\n    }\n  }\n  \n  console.log('\\n🎉 All examples completed!')\n}\n\n// Export individual examples for selective testing\nexport {\n  basicDuplicateDetection,\n  advancedConfiguration,\n  eventMergingExample,\n  batchProcessingExample,\n  realtimeProcessingExample,\n  customFuzzyMatcherExample,\n  performanceMonitoringExample,\n  dataImportExportExample,\n  pipelineIntegrationExample\n}\n\n// Default export for running all examples\nexport default runAllExamples\n"