import { describe, it, expect, beforeEach, jest } from '@jest/globals'\nimport { RecommendationCache } from '@/lib/personalization/RecommendationCache'\nimport { RealTimeUpdate } from '@/lib/personalization/types'\n\ndescribe('RecommendationCache', () => {\n  let cache: RecommendationCache\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n    cache = new RecommendationCache({\n      maxMemoryEntries: 100,\n      defaultTTL: 300, // 5 minutes\n      enableRedis: false\n    })\n  })\n\n  describe('Basic Cache Operations', () => {\n    it('should set and get values', async () => {\n      const key = 'test-key'\n      const value = { data: 'test-data', number: 42 }\n\n      await cache.set(key, value)\n      const retrieved = await cache.get(key)\n\n      expect(retrieved).toEqual(value)\n    })\n\n    it('should return null for non-existent keys', async () => {\n      const result = await cache.get('non-existent-key')\n      expect(result).toBeNull()\n    })\n\n    it('should respect TTL expiration', async () => {\n      const key = 'ttl-test'\n      const value = 'expires-soon'\n      const shortTTL = 0.1 // 100ms\n\n      await cache.set(key, value, shortTTL)\n      \n      // Should be available immediately\n      const immediate = await cache.get(key)\n      expect(immediate).toBe(value)\n\n      // Wait for expiration\n      await new Promise(resolve => setTimeout(resolve, 150))\n      \n      const expired = await cache.get(key)\n      expect(expired).toBeNull()\n    })\n\n    it('should delete specific entries', async () => {\n      const key = 'delete-test'\n      const value = 'to-be-deleted'\n\n      await cache.set(key, value)\n      expect(await cache.get(key)).toBe(value)\n\n      await cache.delete(key)\n      expect(await cache.get(key)).toBeNull()\n    })\n\n    it('should clear all entries', async () => {\n      await cache.set('key1', 'value1')\n      await cache.set('key2', 'value2')\n      await cache.set('key3', 'value3')\n\n      await cache.clear()\n\n      expect(await cache.get('key1')).toBeNull()\n      expect(await cache.get('key2')).toBeNull()\n      expect(await cache.get('key3')).toBeNull()\n    })\n  })\n\n  describe('Bulk Operations', () => {\n    it('should handle bulk get operations', async () => {\n      const entries = new Map([\n        ['key1', 'value1'],\n        ['key2', 'value2'],\n        ['key3', 'value3']\n      ])\n\n      await cache.mset(entries)\n      \n      const keys = ['key1', 'key2', 'key3', 'non-existent']\n      const results = await cache.mget(keys)\n\n      expect(results.get('key1')).toBe('value1')\n      expect(results.get('key2')).toBe('value2')\n      expect(results.get('key3')).toBe('value3')\n      expect(results.get('non-existent')).toBeNull()\n    })\n\n    it('should handle bulk set operations', async () => {\n      const entries = new Map([\n        ['bulk1', { data: 'test1' }],\n        ['bulk2', { data: 'test2' }],\n        ['bulk3', { data: 'test3' }]\n      ])\n\n      await cache.mset(entries)\n\n      for (const [key, value] of entries) {\n        const retrieved = await cache.get(key)\n        expect(retrieved).toEqual(value)\n      }\n    })\n  })\n\n  describe('Pattern Invalidation', () => {\n    it('should invalidate entries matching patterns', async () => {\n      await cache.set('user:123:preferences', 'prefs')\n      await cache.set('user:123:recommendations', 'recs')\n      await cache.set('user:456:preferences', 'other-prefs')\n      await cache.set('system:config', 'config')\n\n      const invalidated = await cache.invalidatePattern('user:123:*')\n      \n      expect(invalidated).toBe(2)\n      expect(await cache.get('user:123:preferences')).toBeNull()\n      expect(await cache.get('user:123:recommendations')).toBeNull()\n      expect(await cache.get('user:456:preferences')).toBe('other-prefs')\n      expect(await cache.get('system:config')).toBe('config')\n    })\n\n    it('should handle complex patterns', async () => {\n      await cache.set('recommendations:user123:music', 'music-recs')\n      await cache.set('recommendations:user123:sports', 'sports-recs')\n      await cache.set('recommendations:user456:music', 'other-music-recs')\n      await cache.set('profiles:user123', 'profile')\n\n      const invalidated = await cache.invalidatePattern('recommendations:user123:*')\n      \n      expect(invalidated).toBe(2)\n      expect(await cache.get('recommendations:user456:music')).toBe('other-music-recs')\n      expect(await cache.get('profiles:user123')).toBe('profile')\n    })\n  })\n\n  describe('Cache Metrics', () => {\n    it('should track cache metrics', async () => {\n      // Generate some cache activity\n      await cache.set('metric-test-1', 'value1')\n      await cache.set('metric-test-2', 'value2')\n      \n      await cache.get('metric-test-1') // Hit\n      await cache.get('metric-test-2') // Hit\n      await cache.get('non-existent') // Miss\n\n      const metrics = await cache.getMetrics()\n\n      expect(metrics).toHaveProperty('hit_rate')\n      expect(metrics).toHaveProperty('miss_rate')\n      expect(metrics).toHaveProperty('entry_count')\n      expect(metrics).toHaveProperty('memory_usage')\n      expect(metrics.entry_count).toBe(2)\n    })\n\n    it('should track popular keys', async () => {\n      const popularKey = 'popular-key'\n      const unpopularKey = 'unpopular-key'\n      \n      await cache.set(popularKey, 'popular-value')\n      await cache.set(unpopularKey, 'unpopular-value')\n      \n      // Access popular key multiple times\n      for (let i = 0; i < 5; i++) {\n        await cache.get(popularKey)\n      }\n      \n      await cache.get(unpopularKey) // Access once\n      \n      const metrics = await cache.getMetrics()\n      expect(metrics.popular_keys).toContain(popularKey)\n    })\n  })\n\n  describe('LRU Eviction', () => {\n    it('should evict least recently used entries when at capacity', async () => {\n      const smallCache = new RecommendationCache({\n        maxMemoryEntries: 3,\n        defaultTTL: 300\n      })\n\n      // Fill cache to capacity\n      await smallCache.set('key1', 'value1')\n      await smallCache.set('key2', 'value2')\n      await smallCache.set('key3', 'value3')\n\n      // Access key1 to make it recently used\n      await smallCache.get('key1')\n\n      // Add new entry, should evict key2 (least recently used)\n      await smallCache.set('key4', 'value4')\n\n      expect(await smallCache.get('key1')).toBe('value1') // Should still exist\n      expect(await smallCache.get('key2')).toBeNull() // Should be evicted\n      expect(await smallCache.get('key3')).toBe('value3') // Should still exist\n      expect(await smallCache.get('key4')).toBe('value4') // Should exist\n    })\n  })\n\n  describe('Real-time Updates', () => {\n    it('should handle real-time cache invalidation', async () => {\n      // Set up some cache entries\n      await cache.set('user:123:recommendations', 'old-recs')\n      await cache.set('user:123:profile', 'profile-data')\n      await cache.set('user:456:recommendations', 'other-recs')\n\n      const update: RealTimeUpdate = {\n        type: 'user_interaction',\n        user_id: '123',\n        data: { event_id: 'event_1', interaction_type: 'save' },\n        timestamp: new Date().toISOString(),\n        requires_recomputation: true\n      }\n\n      await cache.handleRealTimeUpdate(update)\n\n      // User 123's cache should be invalidated\n      expect(await cache.get('user:123:recommendations')).toBeNull()\n      expect(await cache.get('user:123:profile')).toBeNull()\n      \n      // Other user's cache should remain\n      expect(await cache.get('user:456:recommendations')).toBe('other-recs')\n    })\n\n    it('should ignore updates that do not require recomputation', async () => {\n      await cache.set('test-key', 'test-value')\n\n      const update: RealTimeUpdate = {\n        type: 'user_interaction',\n        user_id: '123',\n        data: {},\n        timestamp: new Date().toISOString(),\n        requires_recomputation: false\n      }\n\n      await cache.handleRealTimeUpdate(update)\n\n      // Cache should remain unchanged\n      expect(await cache.get('test-key')).toBe('test-value')\n    })\n  })\n\n  describe('Health Status', () => {\n    it('should report healthy status with good metrics', async () => {\n      // Generate some cache activity to get good metrics\n      for (let i = 0; i < 10; i++) {\n        await cache.set(`key-${i}`, `value-${i}`)\n        await cache.get(`key-${i}`) // Generate hits\n      }\n\n      const health = await cache.getHealthStatus()\n\n      expect(health.status).toBe('healthy')\n      expect(health.memory_cache.entries).toBe(10)\n      expect(health.memory_cache.hit_rate).toBeGreaterThan(0)\n      expect(health.issues).toHaveLength(0)\n    })\n\n    it('should report degraded status with low hit rate', async () => {\n      // Generate mostly misses\n      for (let i = 0; i < 10; i++) {\n        await cache.get(`non-existent-${i}`) // Generate misses\n      }\n\n      const health = await cache.getHealthStatus()\n      expect(health.status).toBe('degraded')\n      expect(health.issues).toContain('Low cache hit rate')\n    })\n\n    it('should report degraded status when near capacity', async () => {\n      const nearCapacityCache = new RecommendationCache({\n        maxMemoryEntries: 10,\n        defaultTTL: 300\n      })\n\n      // Fill cache to 95% capacity\n      for (let i = 0; i < 9; i++) {\n        await nearCapacityCache.set(`key-${i}`, `value-${i}`)\n      }\n\n      const health = await nearCapacityCache.getHealthStatus()\n      expect(health.status).toBe('degraded')\n      expect(health.issues).toContain('Memory cache near capacity')\n    })\n  })\n\n  describe('Cache Warm-up', () => {\n    it('should warm up cache with precomputed values', async () => {\n      const warmUpEntries = [\n        { key: 'popular:music:events', value: ['event1', 'event2'], ttl: 600 },\n        { key: 'popular:sports:events', value: ['event3', 'event4'], ttl: 600 },\n        { key: 'trending:all', value: ['event5', 'event6'] } // Uses default TTL\n      ]\n\n      await cache.warmUp(warmUpEntries)\n\n      for (const entry of warmUpEntries) {\n        const cached = await cache.get(entry.key)\n        expect(cached).toEqual(entry.value)\n      }\n    })\n  })\n\n  describe('Static Utility Methods', () => {\n    it('should create sanitized cache keys', () => {\n      const key = RecommendationCache.createKey([\n        'user',\n        123,\n        'recommendations',\n        true,\n        'special-chars!@#'\n      ])\n\n      expect(key).toBe('user:123:recommendations:true:special-chars___')\n    })\n\n    it('should create versioned cache keys', () => {\n      const versionedKey = RecommendationCache.createVersionedKey(\n        'user:123:preferences',\n        '2.1.0'\n      )\n\n      expect(versionedKey).toBe('user:123:preferences:v2.1.0')\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle get errors gracefully', async () => {\n      // Mock internal error\n      const errorCache = new RecommendationCache()\n      const originalGet = errorCache['getFromMemory']\n      errorCache['getFromMemory'] = jest.fn(() => {\n        throw new Error('Simulated error')\n      })\n\n      const result = await errorCache.get('test-key')\n      expect(result).toBeNull()\n    })\n\n    it('should handle set errors gracefully', async () => {\n      const errorCache = new RecommendationCache()\n      const originalSet = errorCache['setInMemory']\n      errorCache['setInMemory'] = jest.fn(() => {\n        throw new Error('Simulated error')\n      })\n\n      // Should not throw\n      await expect(errorCache.set('test-key', 'test-value')).resolves.toBeUndefined()\n    })\n\n    it('should handle invalidation errors gracefully', async () => {\n      const errorCache = new RecommendationCache()\n      \n      // Mock memory cache to throw during iteration\n      errorCache['memoryCache'] = {\n        keys: () => {\n          throw new Error('Simulated error')\n        }\n      } as any\n\n      const invalidated = await errorCache.invalidatePattern('test:*')\n      expect(invalidated).toBe(0)\n    })\n  })\n\n  describe('Memory Management', () => {\n    it('should track memory usage', async () => {\n      const data = { large: 'x'.repeat(1000) }\n      \n      await cache.set('large-object', data)\n      \n      const metrics = await cache.getMetrics()\n      expect(metrics.memory_usage).toBeGreaterThan(0)\n    })\n\n    it('should clean up expired entries periodically', async () => {\n      // This test would require mocking timers to speed up the cleanup\n      const shortTTL = 0.1 // 100ms\n      \n      await cache.set('expires-soon', 'temporary-data', shortTTL)\n      \n      // Manually trigger cleanup (in real implementation, this happens automatically)\n      cache['cleanupExpiredEntries']()\n      \n      // After cleanup, expired entries should be removed\n      await new Promise(resolve => setTimeout(resolve, 150))\n      \n      // The entry should be cleaned up\n      const metrics = await cache.getMetrics()\n      expect(metrics.entry_count).toBe(0)\n    })\n  })\n})"