import { describe, it, expect, beforeEach } from '@jest/globals'\nimport { InterestMatcher } from '@/lib/personalization/InterestMatcher'\nimport { Event } from '@/types'\nimport {\n  UserBehavior,\n  ComputedInterest,\n  EventInteraction\n} from '@/lib/personalization/types'\n\ndescribe('InterestMatcher', () => {\n  let matcher: InterestMatcher\n\n  beforeEach(() => {\n    matcher = new InterestMatcher()\n  })\n\n  describe('calculateInterestScore', () => {\n    const mockEvent: Event = {\n      id: 'event_1',\n      title: 'Jazz Concert',\n      category: 'music',\n      venue_name: 'Blue Note',\n      price: 50,\n      event_date: '2024-01-15T20:00:00Z',\n      start_time: '20:00',\n      description: 'Amazing jazz performance with world-class musicians',\n      created_at: '2024-01-01T00:00:00Z'\n    }\n\n    const mockUserBehavior: UserBehavior = {\n      id: 'behavior_1',\n      user_id: 'user_1',\n      event_interactions: [\n        {\n          event_id: 'event_2',\n          interaction_type: 'save',\n          duration_seconds: 120,\n          context: { source: 'recommendation' },\n          metadata: { category: 'music' },\n          timestamp: '2024-01-01T12:00:00Z'\n        }\n      ],\n      search_history: [\n        {\n          query: 'jazz concerts',\n          filters: {},\n          results_count: 10,\n          clicked_results: ['event_3'],\n          timestamp: '2024-01-01T10:00:00Z'\n        }\n      ],\n      location_history: [],\n      preference_changes: [],\n      conversion_events: [],\n      session_data: [],\n      computed_interests: [],\n      similarity_scores: [],\n      created_at: '2024-01-01T00:00:00Z',\n      updated_at: '2024-01-01T12:00:00Z'\n    }\n\n    const mockComputedInterests: ComputedInterest[] = [\n      {\n        category: 'music',\n        score: 0.8,\n        confidence: 0.9,\n        evidence: {\n          interaction_count: 5,\n          time_spent: 600,\n          positive_signals: 4,\n          negative_signals: 1\n        },\n        last_updated: '2024-01-01T12:00:00Z'\n      }\n    ]\n\n    it('should calculate interest score for matching category', async () => {\n      const result = await matcher.calculateInterestScore(\n        'user_1',\n        mockEvent,\n        mockUserBehavior,\n        mockComputedInterests\n      )\n\n      expect(result.score).toBeGreaterThan(0.5)\n      expect(result.confidence).toBeGreaterThan(0.5)\n      expect(result.breakdown.category_match).toBeGreaterThan(0)\n    })\n\n    it('should return lower score for non-matching category', async () => {\n      const sportsEvent: Event = {\n        ...mockEvent,\n        id: 'event_sports',\n        title: 'Basketball Game',\n        category: 'sports'\n      }\n\n      const result = await matcher.calculateInterestScore(\n        'user_1',\n        sportsEvent,\n        mockUserBehavior,\n        mockComputedInterests\n      )\n\n      expect(result.score).toBeLessThan(0.5)\n      expect(result.breakdown.category_match).toBeLessThan(0.5)\n    })\n\n    it('should handle empty user behavior gracefully', async () => {\n      const emptyBehavior: UserBehavior = {\n        ...mockUserBehavior,\n        event_interactions: [],\n        search_history: []\n      }\n\n      const result = await matcher.calculateInterestScore(\n        'user_1',\n        mockEvent,\n        emptyBehavior,\n        []\n      )\n\n      expect(result.score).toBeGreaterThan(0)\n      expect(result.confidence).toBeGreaterThan(0)\n    })\n\n    it('should include novelty bonus for new categories', async () => {\n      const novelEvent: Event = {\n        ...mockEvent,\n        category: 'tech' // New category not in user's history\n      }\n\n      const result = await matcher.calculateInterestScore(\n        'user_1',\n        novelEvent,\n        mockUserBehavior,\n        mockComputedInterests\n      )\n\n      expect(result.breakdown.novelty_bonus).toBeGreaterThan(0)\n    })\n  })\n\n  describe('findSimilarEvents', () => {\n    const targetEvent: Event = {\n      id: 'target_event',\n      title: 'Blues Festival',\n      category: 'music',\n      venue_name: 'Downtown Arena',\n      price: 75,\n      description: 'Annual blues festival with multiple artists'\n    }\n\n    const candidateEvents: Event[] = [\n      {\n        id: 'candidate_1',\n        title: 'Jazz Night',\n        category: 'music',\n        venue_name: 'Blue Note',\n        price: 60,\n        description: 'Intimate jazz performance'\n      },\n      {\n        id: 'candidate_2',\n        title: 'Rock Concert',\n        category: 'music',\n        venue_name: 'Stadium',\n        price: 100,\n        description: 'High-energy rock show'\n      },\n      {\n        id: 'candidate_3',\n        title: 'Art Exhibition',\n        category: 'arts',\n        venue_name: 'Gallery',\n        price: 0,\n        description: 'Contemporary art showcase'\n      }\n    ]\n\n    it('should find similar events above threshold', async () => {\n      const results = await matcher.findSimilarEvents(\n        targetEvent,\n        candidateEvents,\n        0.5\n      )\n\n      expect(results.length).toBeGreaterThan(0)\n      results.forEach(result => {\n        expect(result.similarity).toBeGreaterThanOrEqual(0.5)\n        expect(result.event.id).not.toBe(targetEvent.id)\n      })\n    })\n\n    it('should sort results by similarity score', async () => {\n      const results = await matcher.findSimilarEvents(\n        targetEvent,\n        candidateEvents,\n        0.3\n      )\n\n      for (let i = 1; i < results.length; i++) {\n        expect(results[i].similarity).toBeLessThanOrEqual(results[i-1].similarity)\n      }\n    })\n\n    it('should provide similarity reasons', async () => {\n      const results = await matcher.findSimilarEvents(\n        targetEvent,\n        candidateEvents,\n        0.3\n      )\n\n      results.forEach(result => {\n        expect(Array.isArray(result.reasons)).toBe(true)\n        expect(result.reasons.length).toBeGreaterThan(0)\n      })\n    })\n\n    it('should exclude target event from results', async () => {\n      const candidatesWithTarget = [...candidateEvents, targetEvent]\n      \n      const results = await matcher.findSimilarEvents(\n        targetEvent,\n        candidatesWithTarget,\n        0.1\n      )\n\n      results.forEach(result => {\n        expect(result.event.id).not.toBe(targetEvent.id)\n      })\n    })\n  })\n\n  describe('extractInterestsFromBehavior', () => {\n    const mockBehavior: UserBehavior = {\n      id: 'behavior_1',\n      user_id: 'user_1',\n      event_interactions: [\n        {\n          event_id: 'event_1',\n          interaction_type: 'save',\n          duration_seconds: 180,\n          context: { source: 'search' },\n          metadata: { category: 'music' },\n          timestamp: '2024-01-01T12:00:00Z'\n        },\n        {\n          event_id: 'event_2',\n          interaction_type: 'attend',\n          duration_seconds: 300,\n          context: { source: 'recommendation' },\n          metadata: { category: 'music' },\n          timestamp: '2024-01-02T14:00:00Z'\n        },\n        {\n          event_id: 'event_3',\n          interaction_type: 'view',\n          duration_seconds: 30,\n          context: { source: 'browse' },\n          metadata: { category: 'arts' },\n          timestamp: '2024-01-03T10:00:00Z'\n        }\n      ],\n      search_history: [\n        {\n          query: 'jazz concerts near me',\n          filters: {},\n          results_count: 15,\n          clicked_results: ['event_4'],\n          timestamp: '2024-01-01T09:00:00Z'\n        },\n        {\n          query: 'art galleries',\n          filters: {},\n          results_count: 8,\n          clicked_results: [],\n          timestamp: '2024-01-02T16:00:00Z'\n        }\n      ],\n      location_history: [],\n      preference_changes: [],\n      conversion_events: [],\n      session_data: [],\n      computed_interests: [],\n      similarity_scores: [],\n      created_at: '2024-01-01T00:00:00Z',\n      updated_at: '2024-01-03T10:00:00Z'\n    }\n\n    it('should extract interests from event interactions', async () => {\n      const interests = await matcher.extractInterestsFromBehavior(mockBehavior)\n\n      expect(interests.length).toBeGreaterThan(0)\n      \n      const musicInterest = interests.find(i => i.category === 'music')\n      expect(musicInterest).toBeDefined()\n      expect(musicInterest!.score).toBeGreaterThan(0)\n      expect(musicInterest!.evidence.interaction_count).toBe(2)\n    })\n\n    it('should weight different interaction types appropriately', async () => {\n      const interests = await matcher.extractInterestsFromBehavior(mockBehavior)\n      \n      const musicInterest = interests.find(i => i.category === 'music')\n      const artsInterest = interests.find(i => i.category === 'arts')\n      \n      // Music should have higher score due to stronger interactions (save, attend vs view)\n      expect(musicInterest!.score).toBeGreaterThan(artsInterest!.score)\n    })\n\n    it('should include search history in interest calculation', async () => {\n      const interests = await matcher.extractInterestsFromBehavior(mockBehavior)\n      \n      // Both music and arts should appear due to search queries\n      const categories = interests.map(i => i.category)\n      expect(categories).toContain('music')\n      expect(categories).toContain('arts')\n    })\n\n    it('should calculate confidence scores', async () => {\n      const interests = await matcher.extractInterestsFromBehavior(mockBehavior)\n      \n      interests.forEach(interest => {\n        expect(interest.confidence).toBeGreaterThan(0)\n        expect(interest.confidence).toBeLessThanOrEqual(1)\n      })\n    })\n\n    it('should sort interests by score', async () => {\n      const interests = await matcher.extractInterestsFromBehavior(mockBehavior)\n      \n      for (let i = 1; i < interests.length; i++) {\n        expect(interests[i].score).toBeLessThanOrEqual(interests[i-1].score)\n      }\n    })\n\n    it('should filter out low-score interests', async () => {\n      const sparseInteractions: EventInteraction[] = [\n        {\n          event_id: 'event_1',\n          interaction_type: 'view',\n          duration_seconds: 5, // Very brief interaction\n          context: { source: 'browse' },\n          metadata: { category: 'tech' },\n          timestamp: '2024-01-01T12:00:00Z'\n        }\n      ]\n\n      const sparseBehavior: UserBehavior = {\n        ...mockBehavior,\n        event_interactions: sparseInteractions,\n        search_history: []\n      }\n\n      const interests = await matcher.extractInterestsFromBehavior(sparseBehavior)\n      \n      // Should filter out very low scores\n      interests.forEach(interest => {\n        expect(interest.score).toBeGreaterThan(0.05)\n      })\n    })\n  })\n\n  describe('predictCategoryInterest', () => {\n    const mockComputedInterests: ComputedInterest[] = [\n      {\n        category: 'music',\n        score: 0.8,\n        confidence: 0.9,\n        evidence: {\n          interaction_count: 10,\n          time_spent: 1200,\n          positive_signals: 8,\n          negative_signals: 2\n        },\n        last_updated: '2024-01-01T12:00:00Z'\n      },\n      {\n        category: 'arts',\n        score: 0.6,\n        confidence: 0.7,\n        evidence: {\n          interaction_count: 5,\n          time_spent: 600,\n          positive_signals: 4,\n          negative_signals: 1\n        },\n        last_updated: '2024-01-01T12:00:00Z'\n      }\n    ]\n\n    const mockUserBehavior: UserBehavior = {\n      id: 'behavior_1',\n      user_id: 'user_1',\n      event_interactions: [],\n      search_history: [],\n      location_history: [],\n      preference_changes: [],\n      conversion_events: [],\n      session_data: [],\n      computed_interests: [],\n      similarity_scores: [],\n      created_at: '2024-01-01T00:00:00Z',\n      updated_at: '2024-01-01T12:00:00Z'\n    }\n\n    it('should predict interest for related categories', async () => {\n      // Social events are related to music\n      const prediction = await matcher.predictCategoryInterest(\n        'user_1',\n        'social',\n        mockUserBehavior,\n        mockComputedInterests\n      )\n\n      expect(prediction.predicted_score).toBeGreaterThan(0.3)\n      expect(prediction.confidence).toBeGreaterThan(0.1)\n      expect(prediction.reasoning.length).toBeGreaterThan(0)\n    })\n\n    it('should return neutral score for unrelated categories', async () => {\n      const prediction = await matcher.predictCategoryInterest(\n        'user_1',\n        'completely_unknown_category',\n        mockUserBehavior,\n        []\n      )\n\n      expect(prediction.predicted_score).toBe(0.5)\n      expect(prediction.confidence).toBe(0.1)\n      expect(prediction.reasoning).toContain('No related interest data available')\n    })\n\n    it('should provide reasoning for predictions', async () => {\n      const prediction = await matcher.predictCategoryInterest(\n        'user_1',\n        'social',\n        mockUserBehavior,\n        mockComputedInterests\n      )\n\n      expect(Array.isArray(prediction.reasoning)).toBe(true)\n      expect(prediction.reasoning.length).toBeGreaterThan(0)\n    })\n  })\n\n  describe('generateContentRecommendations', () => {\n    const mockInterests: ComputedInterest[] = [\n      {\n        category: 'music',\n        score: 0.8,\n        confidence: 0.9,\n        evidence: {\n          interaction_count: 10,\n          time_spent: 1200,\n          positive_signals: 8,\n          negative_signals: 2\n        },\n        last_updated: '2024-01-01T12:00:00Z'\n      }\n    ]\n\n    const mockCandidateEvents: Event[] = [\n      {\n        id: 'event_1',\n        title: 'Jazz Concert',\n        category: 'music',\n        price: 50\n      },\n      {\n        id: 'event_2',\n        title: 'Rock Show',\n        category: 'music',\n        price: 75\n      },\n      {\n        id: 'event_3',\n        title: 'Art Gallery',\n        category: 'arts',\n        price: 0\n      }\n    ]\n\n    it('should generate content-based recommendations', async () => {\n      const recommendations = await matcher.generateContentRecommendations(\n        mockInterests,\n        mockCandidateEvents,\n        10\n      )\n\n      expect(Array.isArray(recommendations)).toBe(true)\n      expect(recommendations.length).toBeGreaterThan(0)\n      \n      recommendations.forEach(rec => {\n        expect(rec).toHaveProperty('event')\n        expect(rec).toHaveProperty('score')\n        expect(rec).toHaveProperty('matching_interests')\n      })\n    })\n\n    it('should prioritize events matching user interests', async () => {\n      const recommendations = await matcher.generateContentRecommendations(\n        mockInterests,\n        mockCandidateEvents,\n        10\n      )\n\n      // Music events should score higher than arts events\n      const musicRecs = recommendations.filter(r => r.event.category === 'music')\n      const artsRecs = recommendations.filter(r => r.event.category === 'arts')\n      \n      if (musicRecs.length > 0 && artsRecs.length > 0) {\n        expect(musicRecs[0].score).toBeGreaterThan(artsRecs[0].score)\n      }\n    })\n\n    it('should respect limit parameter', async () => {\n      const limit = 2\n      const recommendations = await matcher.generateContentRecommendations(\n        mockInterests,\n        mockCandidateEvents,\n        limit\n      )\n\n      expect(recommendations.length).toBeLessThanOrEqual(limit)\n    })\n\n    it('should sort recommendations by score', async () => {\n      const recommendations = await matcher.generateContentRecommendations(\n        mockInterests,\n        mockCandidateEvents,\n        10\n      )\n\n      for (let i = 1; i < recommendations.length; i++) {\n        expect(recommendations[i].score).toBeLessThanOrEqual(recommendations[i-1].score)\n      }\n    })\n  })\n\n  describe('updateUserInterestVector', () => {\n    it('should update user interest vector based on interaction', async () => {\n      await matcher.updateUserInterestVector(\n        'user_1',\n        'event_1',\n        'save',\n        300\n      )\n\n      // Should complete without error\n      expect(true).toBe(true)\n    })\n\n    it('should handle missing duration', async () => {\n      await matcher.updateUserInterestVector(\n        'user_1',\n        'event_1',\n        'save'\n      )\n\n      // Should complete without error\n      expect(true).toBe(true)\n    })\n  })\n})"