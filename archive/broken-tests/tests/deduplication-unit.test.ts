/**\n * Unit tests for the intelligent deduplication system\n * These tests verify core functionality without external dependencies\n */\n\nimport { Event } from '@/types'\nimport { FuzzyMatcher, EventMerger, ConflictResolver } from '@/lib/scraping/deduplication'\n\n// Test events\nconst testEvents = {\n  original: {\n    id: 'event-1',\n    title: 'Jazz Concert at Blue Note',\n    description: 'Amazing jazz performance',\n    venue_name: 'Blue Note Jazz Club',\n    city_name: 'New York',\n    start_time: '2024-01-15T20:00:00Z',\n    category: 'music',\n    price_min: 25,\n    price_max: 45,\n    latitude: 40.7128,\n    longitude: -74.0060,\n    source: 'primary',\n    tags: ['jazz', 'live music'],\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-01T00:00:00Z'\n  } as Event,\n  \n  duplicate: {\n    id: 'event-2',\n    title: 'Jazz Concert at Blue Note',\n    description: 'Amazing jazz performance featuring local artists',\n    venue_name: 'Blue Note Jazz Club',\n    city_name: 'New York',\n    start_time: '2024-01-15T20:00:00Z',\n    category: 'music',\n    price_min: 25,\n    price_max: 45,\n    latitude: 40.7128,\n    longitude: -74.0060,\n    source: 'eventbrite',\n    external_id: 'eb-123',\n    tags: ['jazz', 'live music', 'evening'],\n    created_at: '2024-01-02T00:00:00Z',\n    updated_at: '2024-01-02T00:00:00Z'\n  } as Event\n}\n\ndescribe('FuzzyMatcher', () => {\n  let matcher: FuzzyMatcher\n  \n  beforeEach(() => {\n    matcher = new FuzzyMatcher()\n  })\n  \n  afterEach(() => {\n    matcher.clearCache()\n  })\n  \n  test('should generate event fingerprints', () => {\n    const fingerprint = matcher.generateFingerprint(testEvents.original)\n    \n    expect(fingerprint).toBeDefined()\n    expect(fingerprint.id).toBe(testEvents.original.id)\n    expect(fingerprint.titleTokens).toBeInstanceOf(Array)\n    expect(fingerprint.titleTokens.length).toBeGreaterThan(0)\n    expect(fingerprint.venueNormalized).toBeDefined()\n    expect(fingerprint.dateKey).toBeDefined()\n    expect(fingerprint.locationKey).toBeDefined()\n  })\n  \n  test('should calculate similarity between events', () => {\n    const fp1 = matcher.generateFingerprint(testEvents.original)\n    const fp2 = matcher.generateFingerprint(testEvents.duplicate)\n    \n    const similarity = matcher.calculateSimilarity(fp1, fp2)\n    \n    expect(similarity).toBeDefined()\n    expect(similarity.title).toBeGreaterThan(0.8) // Very similar titles\n    expect(similarity.venue).toBeGreaterThan(0.8) // Same venue\n    expect(similarity.date).toBe(1) // Exact same date\n    expect(similarity.location).toBeGreaterThan(0.8) // Same location\n    expect(similarity.overall).toBeGreaterThan(0.7) // High overall similarity\n  })\n  \n  test('should find matches', async () => {\n    const matches = await matcher.findMatches(\n      testEvents.original,\n      [testEvents.duplicate]\n    )\n    \n    expect(matches).toBeInstanceOf(Array)\n    expect(matches.length).toBeGreaterThan(0)\n    \n    const match = matches[0]\n    expect(match.eventId).toBe(testEvents.duplicate.id)\n    expect(match.confidence).toBeGreaterThan(0.7)\n    expect(match.reasons).toBeInstanceOf(Array)\n    expect(match.reasons.length).toBeGreaterThan(0)\n  })\n  \n  test('should handle configuration updates', () => {\n    const originalConfig = matcher.getConfig()\n    \n    matcher.updateConfig({\n      thresholds: { title: 0.9 },\n      weights: { title: 0.5 }\n    })\n    \n    const updatedConfig = matcher.getConfig()\n    expect(updatedConfig.thresholds.title).toBe(0.9)\n    expect(updatedConfig.weights.title).toBe(0.5)\n    \n    // Other values should remain unchanged\n    expect(updatedConfig.thresholds.venue).toBe(originalConfig.thresholds.venue)\n  })\n})\n\ndescribe('EventMerger', () => {\n  let merger: EventMerger\n  \n  beforeEach(() => {\n    merger = new EventMerger({\n      thresholds: { overall: 0.8 },\n      weights: { title: 0.4, venue: 0.3, location: 0.2, date: 0.1 },\n      algorithms: { stringMatching: 'hybrid', semanticMatching: true, locationMatching: 'hybrid', fuzzyDate: true },\n      performance: { batchSize: 100, maxCandidates: 50, enableCaching: true, parallelProcessing: true },\n      quality: { minimumQualityScore: 0.7, requireManualReview: false, autoMergeThreshold: 0.95 }\n    })\n  })\n  \n  test('should create merge decisions', () => {\n    const decision = merger.createMergeDecision(\n      testEvents.original,\n      [testEvents.duplicate],\n      'enhance_primary'\n    )\n    \n    expect(decision).toBeDefined()\n    expect(decision.primaryEventId).toBe(testEvents.original.id)\n    expect(decision.duplicateEventIds).toContain(testEvents.duplicate.id)\n    expect(decision.strategy).toBe('enhance_primary')\n    expect(decision.confidence).toBeGreaterThan(0)\n    expect(decision.fieldResolutions).toBeInstanceOf(Array)\n    expect(decision.preview).toBeDefined()\n  })\n  \n  test('should execute merges', async () => {\n    const decision = merger.createMergeDecision(\n      testEvents.original,\n      [testEvents.duplicate],\n      'enhance_primary'\n    )\n    \n    const result = await merger.executeMerge(decision)\n    \n    expect(result.success).toBe(true)\n    expect(result.mergedEvent).toBeDefined()\n    expect(result.changes).toBeInstanceOf(Array)\n    expect(result.errors).toHaveLength(0)\n    \n    // Should preserve primary event ID\n    expect(result.mergedEvent.id).toBe(testEvents.original.id)\n  })\n  \n  test('should validate merge decisions', () => {\n    const decision = merger.createMergeDecision(\n      testEvents.original,\n      [testEvents.duplicate],\n      'enhance_primary'\n    )\n    \n    const validation = merger.validateMergeDecision(decision)\n    \n    expect(validation.isValid).toBe(true)\n    expect(validation.errors).toHaveLength(0)\n  })\n})\n\ndescribe('ConflictResolver', () => {\n  let resolver: ConflictResolver\n  \n  beforeEach(() => {\n    resolver = new ConflictResolver({\n      thresholds: { overall: 0.8 },\n      weights: { title: 0.4, venue: 0.3, location: 0.2, date: 0.1 },\n      algorithms: { stringMatching: 'hybrid', semanticMatching: true, locationMatching: 'hybrid', fuzzyDate: true },\n      performance: { batchSize: 100, maxCandidates: 50, enableCaching: true, parallelProcessing: true },\n      quality: { minimumQualityScore: 0.7, requireManualReview: false, autoMergeThreshold: 0.95 }\n    })\n  })\n  \n  afterEach(() => {\n    resolver.clearHistory()\n  })\n  \n  test('should resolve field conflicts', () => {\n    const resolution = resolver.resolveFieldConflict('title', [\n      { value: 'Jazz Concert', event: testEvents.original },\n      { value: 'Jazz Concert at Blue Note', event: testEvents.duplicate }\n    ])\n    \n    expect(resolution).toBeDefined()\n    expect(resolution.field).toBe('title')\n    expect(resolution.resolvedValue).toBeDefined()\n    expect(resolution.strategy).toBeDefined()\n    expect(resolution.confidence).toBeGreaterThan(0)\n  })\n  \n  test('should handle batch conflict resolution', () => {\n    const events = [testEvents.original, testEvents.duplicate]\n    const resolutions = resolver.resolveBatchConflicts(events, ['title', 'description', 'tags'])\n    \n    expect(resolutions).toBeInstanceOf(Map)\n    expect(resolutions.size).toBeGreaterThan(0)\n    \n    const titleResolution = resolutions.get('title')\n    expect(titleResolution).toBeDefined()\n    expect(titleResolution?.resolvedValue).toBeDefined()\n  })\n  \n  test('should register and manage data sources', () => {\n    resolver.registerDataSource('test-source', {\n      name: 'test-source',\n      reliability: 0.85,\n      lastUpdated: new Date(),\n      dataQuality: 0.80\n    })\n    \n    const sources = resolver.getDataSources()\n    expect(sources.has('test-source')).toBe(true)\n    \n    const testSource = sources.get('test-source')\n    expect(testSource?.reliability).toBe(0.85)\n  })\n  \n  test('should provide resolution statistics', () => {\n    // Perform some resolutions to generate stats\n    resolver.resolveFieldConflict('title', [\n      { value: 'Title 1', event: testEvents.original },\n      { value: 'Title 2', event: testEvents.duplicate }\n    ])\n    \n    const stats = resolver.getResolutionStats()\n    \n    expect(stats.totalResolutions).toBeGreaterThanOrEqual(1)\n    expect(stats.strategyCounts).toBeDefined()\n    expect(stats.avgConfidence).toBeGreaterThan(0)\n    expect(stats.fieldStats).toBeDefined()\n  })\n})\n\ndescribe('Integration Tests', () => {\n  test('should work together for complete deduplication workflow', async () => {\n    const matcher = new FuzzyMatcher()\n    const merger = new EventMerger({\n      thresholds: { overall: 0.8 },\n      weights: { title: 0.4, venue: 0.3, location: 0.2, date: 0.1 },\n      algorithms: { stringMatching: 'hybrid', semanticMatching: true, locationMatching: 'hybrid', fuzzyDate: true },\n      performance: { batchSize: 100, maxCandidates: 50, enableCaching: true, parallelProcessing: true },\n      quality: { minimumQualityScore: 0.7, requireManualReview: false, autoMergeThreshold: 0.95 }\n    })\n    \n    try {\n      // Step 1: Find duplicates\n      const matches = await matcher.findMatches(\n        testEvents.original,\n        [testEvents.duplicate]\n      )\n      \n      expect(matches.length).toBeGreaterThan(0)\n      \n      // Step 2: Create merge decision\n      const decision = merger.createMergeDecision(\n        testEvents.original,\n        [testEvents.duplicate],\n        'enhance_primary'\n      )\n      \n      expect(decision.confidence).toBeGreaterThan(0.7)\n      \n      // Step 3: Execute merge\n      const result = await merger.executeMerge(decision)\n      \n      expect(result.success).toBe(true)\n      expect(result.mergedEvent.id).toBe(testEvents.original.id)\n      \n      // Step 4: Verify enhanced data\n      const merged = result.mergedEvent\n      expect(merged.title).toBeDefined()\n      expect(merged.venue_name).toBeDefined()\n      \n      // Should have combined tags from both events\n      if (merged.tags && testEvents.duplicate.tags) {\n        const originalTags = testEvents.original.tags || []\n        const duplicateTags = testEvents.duplicate.tags || []\n        expect(merged.tags.length).toBeGreaterThanOrEqual(Math.max(originalTags.length, duplicateTags.length))\n      }\n      \n    } finally {\n      matcher.clearCache()\n    }\n  })\n})\n"