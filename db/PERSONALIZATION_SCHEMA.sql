-- SceneScout Personalization System Database Schema\n-- This schema supports the advanced personalization and recommendation engine\n\n-- Enable necessary extensions\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"vector\"; -- For storing embeddings (if using pgvector)\n\n-- User Preferences Table\nCRETE TABLE IF NOT EXISTS user_preferences (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    categories TEXT[] DEFAULT '{}',\n    location_preferences JSONB DEFAULT '{\n        \"preferred_cities\": [],\n        \"max_distance_km\": 50,\n        \"include_virtual\": true\n    }',\n    event_preferences JSONB DEFAULT '{\n        \"price_range\": {\"min\": 0, \"max\": 1000},\n        \"preferred_times\": [],\n        \"preferred_days\": [],\n        \"group_size_preference\": \"any\",\n        \"accessibility_needs\": []\n    }',\n    content_preferences JSONB DEFAULT '{\n        \"preferred_languages\": [\"en\"],\n        \"content_types\": [],\n        \"duration_preference\": \"any\"\n    }',\n    personalization_settings JSONB DEFAULT '{\n        \"enable_ai_recommendations\": true,\n        \"enable_collaborative_filtering\": true,\n        \"enable_location_based\": true,\n        \"privacy_level\": \"private\"\n    }',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE(user_id)\n);\n\n-- User Behavior Data Table\nCREATE TABLE IF NOT EXISTS user_behavior (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    session_count INTEGER DEFAULT 0,\n    total_interaction_time INTEGER DEFAULT 0, -- in seconds\n    last_activity_date TIMESTAMPTZ,\n    behavior_summary JSONB DEFAULT '{}',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE(user_id)\n);\n\n-- User Event Interactions\nCREATE TABLE IF NOT EXISTS user_interactions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    event_id UUID NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n    interaction_type VARCHAR(50) NOT NULL, -- 'view', 'click', 'save', 'share', 'attend', 'rate', 'review'\n    duration_seconds INTEGER,\n    context JSONB DEFAULT '{}', -- source, position, algorithm_version, etc.\n    metadata JSONB DEFAULT '{}', -- event category, venue info, etc.\n    timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_user_interactions_user_id (user_id),\n    INDEX idx_user_interactions_event_id (event_id),\n    INDEX idx_user_interactions_type (interaction_type),\n    INDEX idx_user_interactions_timestamp (timestamp)\n);\n\n-- User Search History\nCREATE TABLE IF NOT EXISTS user_searches (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    query TEXT NOT NULL,\n    filters JSONB DEFAULT '{}',\n    results_count INTEGER DEFAULT 0,\n    clicked_results TEXT[] DEFAULT '{}',\n    location JSONB, -- {\"lat\": number, \"lng\": number}\n    timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_user_searches_user_id (user_id),\n    INDEX idx_user_searches_timestamp (timestamp),\n    INDEX idx_user_searches_query (query)\n);\n\n-- User Location History\nCREATE TABLE IF NOT EXISTS user_location_history (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    latitude DECIMAL(10, 8) NOT NULL,\n    longitude DECIMAL(11, 8) NOT NULL,\n    accuracy INTEGER DEFAULT 100, -- in meters\n    city_id UUID REFERENCES cities(id),\n    neighborhood VARCHAR(255),\n    source VARCHAR(20) DEFAULT 'manual', -- 'gps', 'ip', 'manual'\n    timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_user_location_user_id (user_id),\n    INDEX idx_user_location_timestamp (timestamp),\n    INDEX idx_user_location_coords (latitude, longitude)\n);\n\n-- User Current Location (most recent)\nCREATE TABLE IF NOT EXISTS user_current_location (\n    user_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE,\n    latitude DECIMAL(10, 8) NOT NULL,\n    longitude DECIMAL(11, 8) NOT NULL,\n    accuracy INTEGER DEFAULT 100,\n    city_id UUID REFERENCES cities(id),\n    source VARCHAR(20) DEFAULT 'manual',\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Computed User Interests\nCREATE TABLE IF NOT EXISTS user_computed_interests (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    category VARCHAR(100) NOT NULL,\n    subcategory VARCHAR(100),\n    score DECIMAL(5, 4) NOT NULL CHECK (score >= 0 AND score <= 1),\n    confidence DECIMAL(5, 4) NOT NULL CHECK (confidence >= 0 AND confidence <= 1),\n    evidence JSONB DEFAULT '{\n        \"interaction_count\": 0,\n        \"time_spent\": 0,\n        \"positive_signals\": 0,\n        \"negative_signals\": 0\n    }',\n    last_updated TIMESTAMPTZ DEFAULT NOW(),\n    \n    UNIQUE(user_id, category, subcategory),\n    INDEX idx_user_interests_user_id (user_id),\n    INDEX idx_user_interests_category (category),\n    INDEX idx_user_interests_score (score)\n);\n\n-- User Similarity Scores\nCREATE TABLE IF NOT EXISTS user_similarities (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    similar_user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    similarity_score DECIMAL(5, 4) NOT NULL CHECK (similarity_score >= 0 AND similarity_score <= 1),\n    similarity_type VARCHAR(50) NOT NULL, -- 'collaborative', 'content', 'demographic', 'behavioral'\n    shared_interests TEXT[] DEFAULT '{}',\n    computed_at TIMESTAMPTZ DEFAULT NOW(),\n    \n    UNIQUE(user_id, similar_user_id, similarity_type),\n    INDEX idx_user_similarities_user_id (user_id),\n    INDEX idx_user_similarities_score (similarity_score),\n    CHECK (user_id != similar_user_id)\n);\n\n-- User Preference Changes History\nCREATE TABLE IF NOT EXISTS user_preference_changes (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    field VARCHAR(255) NOT NULL,\n    old_value JSONB,\n    new_value JSONB,\n    change_reason VARCHAR(50) DEFAULT 'explicit', -- 'explicit', 'inferred', 'feedback'\n    timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_preference_changes_user_id (user_id),\n    INDEX idx_preference_changes_timestamp (timestamp)\n);\n\n-- Conversion Events (ticket purchases, etc.)\nCREATE TABLE IF NOT EXISTS user_conversion_events (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    event_id UUID NOT NULL REFERENCES events(id) ON DELETE CASCADE,\n    conversion_type VARCHAR(50) NOT NULL, -- 'ticket_purchase', 'calendar_add', 'share', 'review'\n    value DECIMAL(10, 2), -- monetary value if applicable\n    attribution JSONB DEFAULT '{}', -- recommendation_id, algorithm_version, ab_test_variant\n    timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_conversion_events_user_id (user_id),\n    INDEX idx_conversion_events_event_id (event_id),\n    INDEX idx_conversion_events_type (conversion_type),\n    INDEX idx_conversion_events_timestamp (timestamp)\n);\n\n-- Session Data\nCREATE TABLE IF NOT EXISTS user_session_data (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    session_id VARCHAR(255) NOT NULL,\n    device_type VARCHAR(50), -- 'mobile', 'tablet', 'desktop'\n    duration_minutes INTEGER DEFAULT 0,\n    pages_visited TEXT[] DEFAULT '{}',\n    events_viewed TEXT[] DEFAULT '{}',\n    search_queries TEXT[] DEFAULT '{}',\n    user_agent TEXT,\n    ip_address INET,\n    timestamp TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_session_data_user_id (user_id),\n    INDEX idx_session_data_session_id (session_id),\n    INDEX idx_session_data_timestamp (timestamp)\n);\n\n-- Event Features for ML (precomputed)\nCREATE TABLE IF NOT EXISTS event_features (\n    event_id UUID PRIMARY KEY REFERENCES events(id) ON DELETE CASCADE,\n    category_vector DECIMAL(5, 4)[], -- category embedding\n    price_tier DECIMAL(3, 2) CHECK (price_tier >= 0 AND price_tier <= 1),\n    popularity_score DECIMAL(5, 4) CHECK (popularity_score >= 0 AND popularity_score <= 1),\n    temporal_features JSONB DEFAULT '{}',\n    venue_features JSONB DEFAULT '{}',\n    content_features JSONB DEFAULT '{}',\n    social_features JSONB DEFAULT '{}',\n    content_embedding DECIMAL(5, 4)[], -- text embedding\n    computed_at TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_event_features_popularity (popularity_score),\n    INDEX idx_event_features_price_tier (price_tier)\n);\n\n-- A/B Test Variants\nCREATE TABLE IF NOT EXISTS ab_test_variants (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    name VARCHAR(100) NOT NULL UNIQUE,\n    description TEXT,\n    algorithm_config JSONB NOT NULL DEFAULT '{}',\n    traffic_percentage DECIMAL(5, 4) NOT NULL CHECK (traffic_percentage >= 0 AND traffic_percentage <= 1),\n    is_active BOOLEAN DEFAULT true,\n    metrics JSONB DEFAULT '{\n        \"click_through_rate\": 0,\n        \"conversion_rate\": 0,\n        \"engagement_score\": 0,\n        \"user_satisfaction\": 0\n    }',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Recommendation Logs (for performance tracking)\nCREATE TABLE IF NOT EXISTS recommendation_logs (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    request_id UUID DEFAULT uuid_generate_v4(),\n    recommendations TEXT[] NOT NULL, -- array of event IDs\n    algorithm_version VARCHAR(50) NOT NULL,\n    ab_test_variant VARCHAR(100),\n    context JSONB DEFAULT '{}',\n    performance_metrics JSONB DEFAULT '{}',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_recommendation_logs_user_id (user_id),\n    INDEX idx_recommendation_logs_timestamp (created_at),\n    INDEX idx_recommendation_logs_variant (ab_test_variant)\n);\n\n-- Personalization Metrics (aggregated)\nCREATE TABLE IF NOT EXISTS personalization_metrics (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,\n    time_period VARCHAR(20) NOT NULL, -- '1h', '24h', '7d', '30d'\n    metric_type VARCHAR(50) NOT NULL, -- 'accuracy', 'diversity', 'novelty', etc.\n    metric_value DECIMAL(10, 6) NOT NULL,\n    algorithm_breakdown JSONB DEFAULT '{}',\n    generated_at TIMESTAMPTZ DEFAULT NOW(),\n    \n    INDEX idx_personalization_metrics_user_id (user_id),\n    INDEX idx_personalization_metrics_type (metric_type),\n    INDEX idx_personalization_metrics_period (time_period),\n    INDEX idx_personalization_metrics_timestamp (generated_at)\n);\n\n-- PostGIS functions for location-based queries\n\n-- Function to find events within radius\nCREATE OR REPLACE FUNCTION find_events_within_radius(\n    center_lat DECIMAL,\n    center_lng DECIMAL,\n    radius_km DECIMAL,\n    limit_count INTEGER DEFAULT 1000\n)\nRETURNS TABLE(\n    id UUID,\n    title TEXT,\n    category VARCHAR,\n    venue_name VARCHAR,\n    distance_km DECIMAL\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        e.id,\n        e.title,\n        e.category,\n        e.venue_name,\n        ROUND(\n            6371 * acos(\n                cos(radians(center_lat)) * \n                cos(radians(v.latitude)) * \n                cos(radians(v.longitude) - radians(center_lng)) + \n                sin(radians(center_lat)) * \n                sin(radians(v.latitude))\n            )::DECIMAL, 2\n        ) as distance_km\n    FROM events e\n    JOIN venues v ON e.venue_id = v.id\n    WHERE \n        e.status = 'active' AND\n        e.event_date >= NOW() AND\n        v.latitude IS NOT NULL AND\n        v.longitude IS NOT NULL AND\n        6371 * acos(\n            cos(radians(center_lat)) * \n            cos(radians(v.latitude)) * \n            cos(radians(v.longitude) - radians(center_lng)) + \n            sin(radians(center_lat)) * \n            sin(radians(v.latitude))\n        ) <= radius_km\n    ORDER BY distance_km\n    LIMIT limit_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to find venues within radius\nCREATE OR REPLACE FUNCTION find_venues_within_radius(\n    center_lat DECIMAL,\n    center_lng DECIMAL,\n    radius_km DECIMAL,\n    limit_count INTEGER DEFAULT 500\n)\nRETURNS TABLE(\n    id UUID,\n    name VARCHAR,\n    type VARCHAR,\n    distance_km DECIMAL\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        v.id,\n        v.name,\n        v.type,\n        ROUND(\n            6371 * acos(\n                cos(radians(center_lat)) * \n                cos(radians(v.latitude)) * \n                cos(radians(v.longitude) - radians(center_lng)) + \n                sin(radians(center_lat)) * \n                sin(radians(v.latitude))\n            )::DECIMAL, 2\n        ) as distance_km\n    FROM venues v\n    WHERE \n        v.latitude IS NOT NULL AND\n        v.longitude IS NOT NULL AND\n        6371 * acos(\n            cos(radians(center_lat)) * \n            cos(radians(v.latitude)) * \n            cos(radians(v.longitude) - radians(center_lng)) + \n            sin(radians(center_lat)) * \n            sin(radians(v.latitude))\n        ) <= radius_km\n    ORDER BY distance_km\n    LIMIT limit_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to get event clusters for mapping\nCREATE OR REPLACE FUNCTION get_event_clusters(\n    north_bound DECIMAL,\n    south_bound DECIMAL,\n    east_bound DECIMAL,\n    west_bound DECIMAL,\n    zoom_level INTEGER,\n    cluster_radius DECIMAL DEFAULT 50\n)\nRETURNS TABLE(\n    id TEXT,\n    latitude DECIMAL,\n    longitude DECIMAL,\n    count INTEGER,\n    event_ids TEXT[],\n    categories TEXT[]\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH clustered_events AS (\n        SELECT \n            e.id as event_id,\n            e.category,\n            v.latitude,\n            v.longitude,\n            -- Simple clustering based on proximity\n            FLOOR(v.latitude * (zoom_level * 2)) as lat_cluster,\n            FLOOR(v.longitude * (zoom_level * 2)) as lng_cluster\n        FROM events e\n        JOIN venues v ON e.venue_id = v.id\n        WHERE \n            e.status = 'active' AND\n            e.event_date >= NOW() AND\n            v.latitude BETWEEN south_bound AND north_bound AND\n            v.longitude BETWEEN west_bound AND east_bound\n    )\n    SELECT \n        CONCAT(lat_cluster, '_', lng_cluster) as id,\n        AVG(latitude)::DECIMAL as latitude,\n        AVG(longitude)::DECIMAL as longitude,\n        COUNT(*)::INTEGER as count,\n        ARRAY_AGG(event_id::TEXT) as event_ids,\n        ARRAY_AGG(DISTINCT category) as categories\n    FROM clustered_events\n    GROUP BY lat_cluster, lng_cluster\n    HAVING COUNT(*) > 0;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to get nearby cities\nCREATE OR REPLACE FUNCTION find_nearby_cities(\n    center_lat DECIMAL,\n    center_lng DECIMAL,\n    radius_km DECIMAL,\n    limit_count INTEGER DEFAULT 20\n)\nRETURNS TABLE(\n    id UUID,\n    name VARCHAR,\n    slug VARCHAR,\n    distance_km DECIMAL,\n    event_count INTEGER\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.id,\n        c.name,\n        c.slug,\n        ROUND(\n            6371 * acos(\n                cos(radians(center_lat)) * \n                cos(radians(COALESCE(c.latitude, 0))) * \n                cos(radians(COALESCE(c.longitude, 0)) - radians(center_lng)) + \n                sin(radians(center_lat)) * \n                sin(radians(COALESCE(c.latitude, 0)))\n            )::DECIMAL, 2\n        ) as distance_km,\n        COALESCE(event_stats.event_count, 0)::INTEGER as event_count\n    FROM cities c\n    LEFT JOIN (\n        SELECT \n            city_id,\n            COUNT(*) as event_count\n        FROM events\n        WHERE status = 'active' AND event_date >= NOW()\n        GROUP BY city_id\n    ) event_stats ON c.id = event_stats.city_id\n    WHERE \n        c.is_active = true AND\n        c.latitude IS NOT NULL AND\n        c.longitude IS NOT NULL AND\n        6371 * acos(\n            cos(radians(center_lat)) * \n            cos(radians(c.latitude)) * \n            cos(radians(c.longitude) - radians(center_lng)) + \n            sin(radians(center_lat)) * \n            sin(radians(c.latitude))\n        ) <= radius_km\n    ORDER BY distance_km\n    LIMIT limit_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Triggers for updating timestamps\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Apply update triggers\nCREATE TRIGGER update_user_preferences_updated_at\n    BEFORE UPDATE ON user_preferences\n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER update_user_behavior_updated_at\n    BEFORE UPDATE ON user_behavior\n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER update_ab_test_variants_updated_at\n    BEFORE UPDATE ON ab_test_variants\n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\n-- Row Level Security (RLS) Policies\n\n-- Enable RLS on personalization tables\nALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_behavior ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_interactions ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_searches ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_location_history ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_current_location ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_computed_interests ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_similarities ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_preference_changes ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_conversion_events ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_session_data ENABLE ROW LEVEL SECURITY;\n\n-- Policies for user data access\nCREATE POLICY \"Users can view own preferences\" ON user_preferences\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update own preferences\" ON user_preferences\n    FOR UPDATE USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert own preferences\" ON user_preferences\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view own behavior\" ON user_behavior\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update own behavior\" ON user_behavior\n    FOR UPDATE USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert own behavior\" ON user_behavior\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view own interactions\" ON user_interactions\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert own interactions\" ON user_interactions\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view own searches\" ON user_searches\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert own searches\" ON user_searches\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view own location history\" ON user_location_history\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert own location history\" ON user_location_history\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view own current location\" ON user_current_location\n    FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update own current location\" ON user_current_location\n    FOR UPDATE USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert own current location\" ON user_current_location\n    FOR INSERT WITH CHECK (auth.uid() = user_id);\n\n-- Service role policies for system operations\nCREATE POLICY \"Service role full access\" ON user_preferences\n    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');\n\nCREATE POLICY \"Service role full access\" ON user_behavior\n    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');\n\nCREATE POLICY \"Service role full access\" ON user_interactions\n    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');\n\nCREATE POLICY \"Service role full access\" ON user_computed_interests\n    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');\n\nCREATE POLICY \"Service role full access\" ON user_similarities\n    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');\n\nCREATE POLICY \"Service role full access\" ON recommendation_logs\n    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');\n\n-- Public read access for non-sensitive data\nCREATE POLICY \"Public read access\" ON event_features\n    FOR SELECT USING (true);\n\nCREATE POLICY \"Public read access\" ON ab_test_variants\n    FOR SELECT USING (is_active = true);\n\n-- Comments for documentation\nCOMMENT ON TABLE user_preferences IS 'User personalization preferences and settings';\nCOMMENT ON TABLE user_behavior IS 'Aggregated user behavior data for ML algorithms';\nCOMMENT ON TABLE user_interactions IS 'Individual user interactions with events';\nCOMMENT ON TABLE user_searches IS 'User search history for interest extraction';\nCOMMENT ON TABLE user_location_history IS 'User location data for location-based recommendations';\nCOMMENT ON TABLE user_computed_interests IS 'ML-computed user interests and confidence scores';\nCOMMENT ON TABLE user_similarities IS 'User similarity scores for collaborative filtering';\nCOMMENT ON TABLE event_features IS 'Precomputed event features for ML algorithms';\nCOMMENT ON TABLE ab_test_variants IS 'A/B test configurations for recommendation algorithms';\nCOMMENT ON TABLE recommendation_logs IS 'Logs of recommendation requests for performance analysis';\nCOMMENT ON TABLE personalization_metrics IS 'Aggregated metrics for personalization system performance';\n\nCOMMENT ON FUNCTION find_events_within_radius IS 'Find events within specified radius using haversine formula';\nCOMMENT ON FUNCTION find_venues_within_radius IS 'Find venues within specified radius';\nCOMMENT ON FUNCTION get_event_clusters IS 'Get clustered events for map visualization';\nCOMMENT ON FUNCTION find_nearby_cities IS 'Find cities near specified coordinates with event counts';"