import { describe, it, expect, beforeEach, jest } from '@jest/globals'\nimport { PersonalizationEngine } from '@/lib/personalization/PersonalizationEngine'\nimport { PersonalizationDev } from '@/lib/personalization'\nimport { Event, UserProfile } from '@/types'\n\n// Mock Supabase client\nconst mockSupabaseClient = {\n  from: jest.fn(() => ({\n    select: jest.fn(() => ({\n      eq: jest.fn(() => ({\n        single: jest.fn(() => Promise.resolve({ data: null, error: null })),\n        limit: jest.fn(() => Promise.resolve({ data: [], error: null })),\n        order: jest.fn(() => Promise.resolve({ data: [], error: null }))\n      })),\n      gte: jest.fn(() => ({\n        lte: jest.fn(() => ({\n          not: jest.fn(() => ({\n            limit: jest.fn(() => Promise.resolve({ data: [], error: null }))\n          }))\n        }))\n      })),\n      in: jest.fn(() => Promise.resolve({ data: [], error: null })),\n      limit: jest.fn(() => Promise.resolve({ data: [], error: null }))\n    }))\n  })),\n  rpc: jest.fn(() => Promise.resolve({ data: [], error: null }))\n}\n\n// Mock the location service\njest.mock('@/lib/personalization/LocationService', () => {\n  return {\n    LocationService: jest.fn().mockImplementation(() => ({\n      findEventsWithinRadius: jest.fn(() => Promise.resolve([])),\n      calculateDistance: jest.fn(() => 5.0)\n    }))\n  }\n})\n\n// Mock the interest matcher\njest.mock('@/lib/personalization/InterestMatcher', () => {\n  return {\n    InterestMatcher: jest.fn().mockImplementation(() => ({\n      calculateInterestScore: jest.fn(() => Promise.resolve({\n        score: 0.8,\n        confidence: 0.9,\n        breakdown: {\n          category_match: 0.8,\n          content_similarity: 0.7,\n          behavioral_signals: 0.6,\n          novelty_bonus: 0.1\n        }\n      }))\n    }))\n  }\n})\n\n// Mock the event ranker\njest.mock('@/lib/personalization/EventRanker', () => {\n  return {\n    EventRanker: jest.fn().mockImplementation(() => ({\n      rankEvents: jest.fn(() => Promise.resolve([\n        {\n          event_id: 'event_1',\n          score: 0.9,\n          confidence: 0.8,\n          explanation: {\n            primary_reason: 'interest_alignment',\n            contributing_factors: ['category_match', 'location'],\n            algorithm_weights: { category_match: 0.4, location: 0.3 }\n          },\n          metadata: {\n            algorithm_version: '1.0.0',\n            computation_time_ms: 50,\n            cache_hit: false\n          }\n        }\n      ]))\n    }))\n  }\n})\n\n// Mock the cache\njest.mock('@/lib/personalization/RecommendationCache', () => {\n  return {\n    RecommendationCache: jest.fn().mockImplementation(() => ({\n      get: jest.fn(() => Promise.resolve(null)),\n      set: jest.fn(() => Promise.resolve()),\n      invalidatePattern: jest.fn(() => Promise.resolve(0))\n    }))\n  }\n})\n\n// Mock the profile builder\njest.mock('@/lib/personalization/UserProfileBuilder', () => {\n  return {\n    UserProfileBuilder: jest.fn().mockImplementation(() => ({\n      updateFromInteraction: jest.fn(() => Promise.resolve())\n    }))\n  }\n})\n\ndescribe('PersonalizationEngine', () => {\n  let engine: PersonalizationEngine\n  const mockSupabaseUrl = 'https://test.supabase.co'\n  const mockSupabaseKey = 'test-key'\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n    engine = new PersonalizationEngine(mockSupabaseUrl, mockSupabaseKey)\n  })\n\n  describe('Constructor', () => {\n    it('should initialize with default configuration', () => {\n      expect(engine).toBeInstanceOf(PersonalizationEngine)\n    })\n\n    it('should accept custom configuration', () => {\n      const customConfig = {\n        algorithms: {\n          collaborative_filtering: { enabled: false, weight: 0 },\n          content_based: { enabled: true, weight: 1.0 }\n        }\n      }\n      \n      const customEngine = new PersonalizationEngine(\n        mockSupabaseUrl,\n        mockSupabaseKey,\n        customConfig\n      )\n      \n      expect(customEngine).toBeInstanceOf(PersonalizationEngine)\n    })\n  })\n\n  describe('getRecommendations', () => {\n    it('should return recommendations for valid request', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest({\n        user_id: 'test-user-123',\n        limit: 10\n      })\n\n      const response = await engine.getRecommendations(request)\n\n      expect(response).toHaveProperty('recommendations')\n      expect(response).toHaveProperty('cache_info')\n      expect(response).toHaveProperty('performance')\n      expect(Array.isArray(response.recommendations)).toBe(true)\n    })\n\n    it('should handle cache hits', async () => {\n      // Mock cache hit\n      const mockCache = engine['cache']\n      mockCache.get = jest.fn(() => Promise.resolve({\n        recommendations: [],\n        cache_info: { hit: true, ttl_seconds: 1800, cache_key: 'test' },\n        performance: { total_time_ms: 5, db_time_ms: 0, ml_time_ms: 0, cache_time_ms: 5 }\n      }))\n\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await engine.getRecommendations(request)\n\n      expect(response.cache_info.hit).toBe(true)\n      expect(mockCache.get).toHaveBeenCalled()\n    })\n\n    it('should handle errors gracefully', async () => {\n      // Mock an error in the ranking process\n      const mockRanker = engine['eventRanker']\n      mockRanker.rankEvents = jest.fn(() => Promise.reject(new Error('Ranking failed')))\n\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await engine.getRecommendations(request)\n\n      // Should return fallback recommendations\n      expect(response).toHaveProperty('recommendations')\n      expect(response.performance.total_time_ms).toBeGreaterThan(0)\n    })\n\n    it('should respect limit parameter', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest({\n        limit: 5\n      })\n\n      const response = await engine.getRecommendations(request)\n      expect(response.recommendations.length).toBeLessThanOrEqual(5)\n    })\n\n    it('should handle location-based filtering', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest({\n        context: {\n          location: { lat: 37.7749, lng: -122.4194, radius_km: 25 }\n        }\n      })\n\n      const response = await engine.getRecommendations(request)\n      expect(response).toHaveProperty('recommendations')\n    })\n\n    it('should filter out low-confidence recommendations', async () => {\n      // Mock low-confidence recommendations\n      const mockRanker = engine['eventRanker']\n      mockRanker.rankEvents = jest.fn(() => Promise.resolve([\n        {\n          event_id: 'event_1',\n          score: 0.05, // Below threshold\n          confidence: 0.1,\n          explanation: {\n            primary_reason: 'low_confidence',\n            contributing_factors: [],\n            algorithm_weights: {}\n          },\n          metadata: {\n            algorithm_version: '1.0.0',\n            computation_time_ms: 10,\n            cache_hit: false\n          }\n        }\n      ]))\n\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await engine.getRecommendations(request)\n\n      // Should filter out low-score recommendations\n      expect(response.recommendations.length).toBe(0)\n    })\n  })\n\n  describe('updateUserPreferences', () => {\n    it('should update user preferences from interaction', async () => {\n      const userId = 'test-user-123'\n      const interaction = {\n        event_id: 'event_1',\n        interaction_type: 'save',\n        metadata: { category: 'music' }\n      }\n\n      await engine.updateUserPreferences(userId, interaction)\n\n      const profileBuilder = engine['profileBuilder']\n      expect(profileBuilder.updateFromInteraction).toHaveBeenCalledWith(userId, interaction)\n    })\n\n    it('should invalidate cache after preference update', async () => {\n      const userId = 'test-user-123'\n      const interaction = { event_id: 'event_1', interaction_type: 'save' }\n\n      const mockCache = engine['cache']\n      await engine.updateUserPreferences(userId, interaction)\n\n      expect(mockCache.invalidatePattern).toHaveBeenCalledWith(`user:${userId}:*`)\n    })\n  })\n\n  describe('getPersonalizationMetrics', () => {\n    it('should return metrics for user', async () => {\n      const userId = 'test-user-123'\n      const timePeriod = '30d'\n\n      const metrics = await engine.getPersonalizationMetrics(userId, timePeriod)\n\n      expect(metrics).toHaveProperty('user_id', userId)\n      expect(metrics).toHaveProperty('time_period', timePeriod)\n      expect(metrics).toHaveProperty('metrics')\n      expect(metrics).toHaveProperty('algorithm_performance')\n      expect(metrics.metrics).toHaveProperty('recommendation_accuracy')\n      expect(metrics.metrics).toHaveProperty('click_through_rate')\n    })\n  })\n\n  describe('A/B Testing', () => {\n    it('should handle A/B test variants', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest({\n        ab_test_variant: 'variant_a'\n      })\n\n      const response = await engine.getRecommendations(request)\n      expect(response).toHaveProperty('recommendations')\n    })\n\n    it('should assign variants consistently for same user', async () => {\n      const userId = 'test-user-123'\n      const request1 = PersonalizationDev.createMockRecommendationRequest({ user_id: userId })\n      const request2 = PersonalizationDev.createMockRecommendationRequest({ user_id: userId })\n\n      const response1 = await engine.getRecommendations(request1)\n      const response2 = await engine.getRecommendations(request2)\n\n      // Both should have same variant assignment logic\n      expect(response1).toHaveProperty('recommendations')\n      expect(response2).toHaveProperty('recommendations')\n    })\n  })\n\n  describe('Performance', () => {\n    it('should complete recommendations within reasonable time', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const startTime = Date.now()\n      \n      const response = await engine.getRecommendations(request)\n      const duration = Date.now() - startTime\n\n      expect(duration).toBeLessThan(5000) // Should complete within 5 seconds\n      expect(response.performance.total_time_ms).toBeGreaterThan(0)\n    })\n\n    it('should track performance metrics', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await engine.getRecommendations(request)\n\n      expect(response.performance).toHaveProperty('total_time_ms')\n      expect(response.performance).toHaveProperty('db_time_ms')\n      expect(response.performance).toHaveProperty('ml_time_ms')\n      expect(response.performance).toHaveProperty('cache_time_ms')\n    })\n  })\n\n  describe('Edge Cases', () => {\n    it('should handle empty event dataset', async () => {\n      // Mock empty events response\n      mockSupabaseClient.from = jest.fn(() => ({\n        select: jest.fn(() => ({\n          eq: jest.fn(() => ({\n            gte: jest.fn(() => ({\n              limit: jest.fn(() => Promise.resolve({ data: [], error: null }))\n            }))\n          }))\n        }))\n      }))\n\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await engine.getRecommendations(request)\n\n      expect(response.recommendations).toHaveLength(0)\n    })\n\n    it('should handle new user with no history', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest({\n        user_id: 'new-user-no-history'\n      })\n\n      const response = await engine.getRecommendations(request)\n      expect(response).toHaveProperty('recommendations')\n    })\n\n    it('should handle invalid location data', async () => {\n      const request = PersonalizationDev.createMockRecommendationRequest({\n        context: {\n          location: { lat: 200, lng: 300 } // Invalid coordinates\n        }\n      })\n\n      const response = await engine.getRecommendations(request)\n      expect(response).toHaveProperty('recommendations')\n    })\n\n    it('should handle database errors gracefully', async () => {\n      // Mock database error\n      mockSupabaseClient.from = jest.fn(() => ({\n        select: jest.fn(() => ({\n          eq: jest.fn(() => ({\n            single: jest.fn(() => Promise.resolve({ \n              data: null, \n              error: { message: 'Database connection failed' } \n            }))\n          }))\n        }))\n      }))\n\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await engine.getRecommendations(request)\n\n      // Should still return fallback recommendations\n      expect(response).toHaveProperty('recommendations')\n    })\n  })\n\n  describe('Configuration', () => {\n    it('should apply custom algorithm weights', async () => {\n      const customConfig = {\n        algorithms: {\n          collaborative_filtering: { enabled: true, weight: 0.8 },\n          content_based: { enabled: true, weight: 0.2 },\n          location_based: { enabled: false, weight: 0 },\n          trending: { enabled: false, weight: 0 }\n        }\n      }\n\n      const customEngine = new PersonalizationEngine(\n        mockSupabaseUrl,\n        mockSupabaseKey,\n        customConfig\n      )\n\n      const request = PersonalizationDev.createMockRecommendationRequest()\n      const response = await customEngine.getRecommendations(request)\n\n      expect(response).toHaveProperty('recommendations')\n    })\n\n    it('should respect diversity settings', async () => {\n      const diversityConfig = {\n        diversity: {\n          enable_diversity: true,\n          diversity_lambda: 0.8,\n          max_same_category: 2,\n          max_same_venue: 1\n        }\n      }\n\n      const diverseEngine = new PersonalizationEngine(\n        mockSupabaseUrl,\n        mockSupabaseKey,\n        diversityConfig\n      )\n\n      const request = PersonalizationDev.createMockRecommendationRequest({ limit: 20 })\n      const response = await diverseEngine.getRecommendations(request)\n\n      expect(response).toHaveProperty('recommendations')\n    })\n  })\n})"